{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./src/Component.js","webpack://[name]/./src/GameGUI.js","webpack://[name]/./src/Rout.js","webpack://[name]/./src/Router.js","webpack://[name]/./src/index.js","webpack://[name]/./src/router.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAO;AACP,2BAA2B,aAAa,qBAAqB;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,UAAU;AACxD;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oDAAoD,SAAS,oBAAoB,aAAa,eAAe,SAAS;;AAEtH;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,sDAAsD;AAC/F;;AAEA;AACA,6CAA6C,qDAAqD;AAClG;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,uDAAuD;AACjG;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2EAA2E,SAAS,yBAAyB,iBAAiB,iBAAiB,SAAS;AACxJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AChSA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD,YAAY,+CAA+C,UAAU,SAAS,QAAQ;AAC9I;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wDAAwD,oBAAoB;AAC5E;;AAEA;AACA;;AAEA;;AAEA,wCAAwC,mDAAmD;AAC3F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,UAAU,qBAAqB,QAAQ;AACnG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,mCAAmC;AACpE;AACA,C;;;;;;;;;;;;AC9LA;AAAA;AAAA;AAAA;AAA2C;AACN;;AAE9B,mBAAmB,uDAAS;AACnC;AACA,IAAI,iDAAM;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,WAAW,iDAAM;AACjB;AACA;AACA;;AAEA;AACA,YAAY,qEAAqE;AACjF;AACA,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,E;;;;;;;;;;;;AC9BnB;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA,2EAA2E;AAC3E;AACA;;AAEA;AACA;AACA,mBAAmB,oDAAoD;AACvE;;AAEA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA,8BAA8B,oCAAoC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACO,4B;;;;;;;;;;;;ACtRP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;;AAED;AACD;AACF;;AAEvB,kHAAO,E;;;;;;;;;;;;ACNtB;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA,2EAA2E;AAC3E;AACA;;AAEA;AACA;AACA,mBAAmB,oDAAoD;AACvE;;AAEA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA,8BAA8B,oCAAoC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACO,4B","file":"GameGUI.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GameGUI\"] = factory();\n\telse\n\t\troot[\"GameGUI\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","export class Component {\n  constructor ( option = {}, config = {}, dataFromParent = {} ) {\n    // Note: \"option\" and \"config\" are registered at first include when Comp is instantiated.\n    //       These props wont be updated even if then change at subsequent re-renderings.\n    this.option                     = option;\n    this.config                     = config;\n\n    this.id                         = typeof config.id !== 'undefined' ? config.id : this.uid();\n    this.type                       = this.getTypeOfComp( this );\n    this.classNameInHtml            = this.camelCaseToSnakeCase( this.type );\n    this.dom                        = this.createDomRepresentation();\n                                      // Note: \"this.dom\" this is a wrapper element. The output of \"this.render(..)\"\n                                      // is placed inside this wrapper. The wrapper is created only once at\n                                      // Comp instantiation, but its content is created from scratch, then injected at\n                                      // every Comp Render call - at this.render(..).\n    this.listObjCompChildByType     = {}; // Cache previously rendered Comps here.\n    this.html                       = '';\n    this.ctrChildByType             = {};\n\n    this.state                      = {};\n    this.isStateUpdated             = false; // when Comp State is updated, this is set to true till\n                                             // State Change is rendered to HTML/DOM\n    this.dataFromParentAsStringPrev = undefined;\n\n    // Run Life Cycle Method if defined on Comp Instance\n    if  (typeof this.afterInstantiation !== 'undefined') {\n      this.afterInstantiation( dataFromParent );\n    }\n  }\n\n  getTypeOfComp ( comp ) {\n    // Issue: Babel transpiles MyCompName to MyCompName_ImportedCompName. We are filtering this off here.\n    //        If we ignored this, the code wouldn't be compilable.\n    const type = Object.getPrototypeOf(comp).constructor.name;\n    const listTypePart = type.split('_');\n    return listTypePart[ listTypePart.length -1 ];\n  }\n\n  createDomRepresentation () {\n    const domElement = document.createElement('div');\n    domElement.classList.add( this.classNameInHtml );\n    domElement.setAttribute('id', this.id);\n\n    return domElement;\n  }\n\n  render() {\n    return `<span>Placeholder text for Comp ${this.type}</span>`;\n  }\n\n  /**\n   * Syntax: ..${this.include(ClassComp, dataFromParent, config)}\n   * Use \"include\" inside any \"render\" method to embed Comps inside Comps.\n   * It returns a Placeholder HTML Snippet, that is included in the Parent Comps DOM till\n   * the next Game GUI Render Event will call \"renderToHtmlAndDomify\" on Parent Comp,\n   * when all Placeholder HTML Snippet will be replaced with the relevant Included Comps DOM.\n   * @param ClassComp\n   * @param dataFromParent\n   * @param config\n   * @returns {string|*}\n   */\n  include ( ClassComp, dataFromParent, config ) {\n    // If Smart Comp (Class)\n    if ( ClassComp.prototype instanceof Component ) {\n      const typeComp = ClassComp.name;\n      const ctrChild = this.ctrChildByType[ typeComp ] = typeof this.ctrChildByType[ typeComp ] === 'undefined' ?\n                                                            0                                                   :\n                                                            ++this.ctrChildByType[ typeComp ];\n\n      const idCompChild = (config && typeof config.id !== 'undefined') ? config.id : ctrChild;\n      this.listObjCompChildByType[ typeComp ] = this.listObjCompChildByType[ typeComp ] || {};\n      let compChild = this.listObjCompChildByType[ typeComp ][ idCompChild ];\n\n      // Create new instance of Comp only if it hasn't been created yet\n      if ( typeof compChild === 'undefined' ) {\n        compChild = this.listObjCompChildByType[ typeComp ][ idCompChild ] = new ClassComp( this.option, config, dataFromParent );\n        // Note: \"option\" is a global in the scope of Game GUI, therefore we pass it along to every Child Comp,\n        //       hence making it available in every Comp through \"this.option\".\n        //       \"config\" and \"dataFromParent\" on the other hand are specific to each Comp,\n        //       therefore we pass in a new one at every include, unlike we do with \"option\".\n        //       \"option\" and \"config\" both are registered when the Comp is instantiated (at first inclusion),\n        //       then we never update them again, even if we include them multiple times with different config,\n        //       that won't effect the original config. Therefore, you are welcome to modify it (e.g. in constructor)\n        //       after Comp is instantiated, those modifications will remain.\n        //       \"dataFromParent\" on the other hand will be update and passed in to \"render\" method,\n        //       every time the Parent Comp is re-rendered.\n\n        // Hook up Game GUI Methods: scheduler, indexComp\n        // Note: make sure you dont bind this, you need scheduler to resolve to ui framework,\n        //       and not to Comp instance.\n        //       These hooked up methods wont be used/called at construction time,\n        //       therefore there is no problem hooking them up after Comp Instantiation.\n        compChild.scheduleRendering = this.scheduleRendering;\n        compChild.indexComp         = this.indexComp;\n        compChild.listBindExternal  = this.listBindExternal;\n\n        // Index Comp (by \"type\" and \"id\") for quick access, right after its created and even before its rendered.\n        // Note: The rendering of Root Comp will trigger the indexing of all Sub Comps.\n        this.indexComp( compChild );\n      }\n\n      compChild.renderToHtmlAndDomify( dataFromParent );\n      // Note: \"dataFromParent\" from Parent Comp is updated in Child Comp by \"include\", but\n      //       \"config\" and \"option\" are not, they are passed in only at first inclusion (at Comp Instantiation)\n\n      const idFromConfig = (config && typeof config.id !== 'undefined') ? config.id : '';\n\n      return `<div class=\"comp-placeholder\" type=\"${typeComp}\" id-from-config=\"${idFromConfig}\" ctr-child=\"${ctrChild}\">placeholder text</div>`;\n\n    // If Dumb Comp (Function)\n    } else {\n      return ClassComp( dataFromParent, this.option );\n    }\n  };\n\n  renderToHtmlAndDomify ( dataFromParent ) {\n    // Optimise Rendering to HTML\n    // Note: Comp HTML Representation can change one of three ways:\n    //       A) Data Passed in from Parent Comp has changed\n    //       B) State has changed\n    //       C) HTML Representation of Comp has never been created before, therefore\n    //          what ever we render will be different from current HTML Representation of the Comp.\n\n    const renderBecauseDataPassedInChanged = this.isRenderBecauseDataPassedInChanged ( dataFromParent );\n\n    // Don't skip if HTML representation of Comp has never been rendered yet.\n    // Skip only if Data Passed In From Parent Comp hasn't changed and the sate of the Comp hasn't changed either\n    if (this.html !== '' &&\n        !renderBecauseDataPassedInChanged &&\n        !this.isStateUpdated\n    ) {\n      return false;\n    }\n\n    // Note: Record of Data Passed In From Parent has already been updated by \"isRenderBecauseDataPassedInChanged\"\n    //       because we have already stringified Data Passed In From Parent in \"isRenderBecauseDataPassedInChanged\",\n    //       therefore we don't want to do it twice, efficiency\n    // !! this.dataFromParentAsStringPrev = JSON.stringify( dataFromParent );\n\n    // Render to HTML String\n    this.ctrChildByType = {};\n    var htmlNewRender   = this.render( dataFromParent );\n    this.isStateUpdated = false; // Updated Comp State is rendered to HTML/DOM at \"this.render(..)\", so we reset it here\n\n    // Skip ReDomify if Comp Shallow Render looks the same\n    // Note: if the Data Passed In From Parent has changed and/or Comp State has changed,\n    //       that doesn't necessarily mean that the rendered HTML is different\n    if ( htmlNewRender === this.html ) {\n      return false;\n    }\n\n    this.html = htmlNewRender;\n\n    // DOMify HTML String\n    this.dom.innerHTML = this.html;\n\n    // Bind Built in Event Handlers automatically right after DOM is ready\n    this.doBindExternal();\n\n    // Run Life Cycle Method if defined on Comp Instance\n    if  (typeof this.afterRender !== 'undefined') {\n      this.afterRender();\n    }\n\n    // Inject Child Comps if any\n    this.replaceCompPlaceholderAll( this.dom );\n\n    return true;\n  }\n\n  isRenderBecauseDataPassedInChanged ( dataFromParent ) {\n    const isUndefinedDataFromParentAsStringPrev = typeof this.dataFromParentAsStringPrev === 'undefined';\n    const isUndefinedDataFromParentAsString     = typeof dataFromParent                  === 'undefined';\n\n    // Scenario 1)  prev === undefined && passed === undefined --> DON'T RENDER\n    if ( isUndefinedDataFromParentAsStringPrev &&\n         isUndefinedDataFromParentAsString\n    ) {\n      return false;\n    }\n\n    const dataFromParentAsString = JSON.stringify( dataFromParent );\n\n    // Scenario 2)  prev === undefined && passed !== undefined --> RENDER\n    if ( isUndefinedDataFromParentAsStringPrev &&\n         !isUndefinedDataFromParentAsString\n    ) {\n      this.dataFromParentAsStringPrev = dataFromParentAsString;\n      return true;\n    }\n\n    // Scenario 3)  prev !== undefined && passed === undefined --> RENDER\n    if ( !isUndefinedDataFromParentAsStringPrev &&\n         isUndefinedDataFromParentAsString\n    ) {\n      this.dataFromParentAsStringPrev = dataFromParentAsString;\n      return true;\n    }\n\n    // Scenario 4)  prev !== undefined && passed !== undefined --> COMPARE\n    if ( !isUndefinedDataFromParentAsStringPrev &&\n         !isUndefinedDataFromParentAsString\n    ) {\n      // Compare / same       --> DON'T RENDER\n      if ( this.dataFromParentAsStringPrev === dataFromParentAsString) {\n        return false;\n\n      // Compare / different  --> RENDER\n      } else {\n        this.dataFromParentAsStringPrev = dataFromParentAsString;\n        return true;\n      }\n    }\n\n    console.error('Something unexpected happened o_0?');\n    debugger;\n  }\n\n  doBindExternal() {\n    // ui-MY-NAME-COMES-HERE | Do link bindings automatically right after rendering\n    // Note: Binding happens before Child Comps are injected so Encapsulation is unharmed\n    if (this.listBindExternal && 0 < this.listBindExternal.length) {\n      for (let indexListBindExternal = 0; indexListBindExternal < this.listBindExternal.length; indexListBindExternal++) {\n        const bindExternal = this.listBindExternal[ indexListBindExternal ];\n\n        const listNodeBtnUiClick = this.dom.querySelectorAll('['+bindExternal.nameAttribute+']');\n        for (let indexListNodeBtnUiClick = 0; indexListNodeBtnUiClick < listNodeBtnUiClick.length; indexListNodeBtnUiClick++) {\n          const domNode = listNodeBtnUiClick[ indexListNodeBtnUiClick ];\n\n          const valueAttrib = domNode.getAttribute(bindExternal.nameAttribute);\n          domNode.addEventListener(bindExternal.typeEvent, (evt) => {\n            bindExternal.callback.call(this, valueAttrib, domNode, evt);\n          }, false);\n        }\n      }\n    }\n  }\n\n  replaceCompPlaceholderAll () {\n    // Get a list of all Placeholder Child Component\n    var nodeListPlaceholder = this.dom.querySelectorAll('.comp-placeholder');\n\n    // Iterate over all Placeholder Child Comps and replace them with Comp DOM\n    for (let indexNodeListPlaceholder = 0; indexNodeListPlaceholder < nodeListPlaceholder.length; indexNodeListPlaceholder++) {\n      let dPlaceholder = nodeListPlaceholder[ indexNodeListPlaceholder ];\n\n      const typeComp          = dPlaceholder.getAttribute('type');\n      const idCompFromConfig  = dPlaceholder.getAttribute('id-from-config');\n      const ctrChild          = dPlaceholder.getAttribute('ctr-child');\n\n      const idCompChild = !!idCompFromConfig ? idCompFromConfig : ctrChild;\n      const compChild   = this.listObjCompChildByType[ typeComp ][ idCompChild ];\n\n      if (!compChild) {\n        const message  = `Warning: Component can't be found: typeComp===\"${typeComp}\", idCompFromConfig===\"${idCompFromConfig}\", ctrChild===\"${ctrChild}\". State of Cached Comps: `;\n        console.warn(message, JSON.stringify(this.listObjCompChildByType));\n        continue;\n      }\n\n      compChild.dom = dPlaceholder.insertAdjacentElement('beforebegin', compChild.dom);\n      dPlaceholder.parentNode.removeChild(dPlaceholder);\n    }\n  };\n\n  getState () {\n    return this.state;\n  };\n\n  setState ( stateNew ) {\n    this.state = stateNew;\n    this.isStateUpdated = true;\n\n    if ( typeof this.scheduleRendering !== 'undefined' ) {\n      this.scheduleRendering( this );\n    }\n  };\n\n\n  // # Utility\n  // # #######\n\n  camelCaseToSnakeCase (str) {\n    return str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase()\n  }\n\n  uid () {\n    return Date.now()+''+Math.round(Math.random() * 100000);\n  }\n}","export class GameGUI {\n  constructor(RootComp, selectorGuiRoot, option, configRootComp) {\n    // Reg Root Comp automatically if requirements are fulfilled\n    // Note: don't run it by default, you may want to control the steps.\n    if (typeof RootComp === 'undefined' ||\n        typeof selectorGuiRoot === 'undefined'\n    ) {\n      return;\n    }\n\n    this.init(option);\n    this.regRootComp(RootComp, selectorGuiRoot, configRootComp);\n\n    // Register Global 'gui-click' Built in Event Handler\n    this.registerBindingBuiltIn();\n\n    // Call the very first render ASAP\n    // Note:  Otherwise you might see a brief flash\n    //        Running render in the constructor means, all includes will be called recursively,\n    //        therefore all Comp / SubC omp Instantiation will happen sequentially when Game GUI is Instantiated.\n    //        That said, all Comps are indexed and ready to be accessed right after Game GUI Instantiation.\n    setTimeout(this.render.bind(this), 0);\n  };\n\n  init(option = {}) {\n    this.optionDefault = {\n      fps: 60,\n    };\n\n    // Should compose option from default options, and options passed in at construction\n    this.option = {\n      ...this.optionDefault,\n      ...option,\n    };\n\n    this.isRenderingDue = false;\n    this.listObjIdRenderingScheduled = {};\n\n    // Indexed list of all rendered Comps\n    this.listObjTypeComp  = {};\n    this.listObjIdComp    = {};\n\n    // Store and call from the list of callbacks passed in to be run right after rendering(s) is complete.\n    this.listBindExternal = [];\n    this.listObjTypeListEventListener = {};\n    this.isDOMContentReady = false;\n\n    // Note: Don't worry about calling render 60 times a sec,\n    // render method start with \"if(!this.isRenderingDue ) return;\"\n    this.tokenUiRender;\n    if (typeof interval !== 'undefined') {\n      this.tokenUiRender = interval.setInterval(this.render.bind(this), Math.floor(1000/this.option.fps));\n    } else {\n      this.tokenUiRender = setInterval(this.render.bind(this), Math.floor(1000/this.option.fps));\n    }\n  }\n\n  regRootComp ( RootComp, selectorGuiRoot, configRootComp ) {\n    // Get UI Root\n    this.domRoot = document.querySelector( selectorGuiRoot );\n\n    // Throws if Root DOM Element doesn't exist\n    if (this.domRoot === null) {\n      throw('ERROR: DOM Root can\\'t be found by using the provided selector: ' + selectorGuiRoot);\n    }\n\n    // Instantiate Root Comp\n    this.rootComp = new RootComp( this.option, configRootComp );\n\n    // Hook up Game GUI Methods: scheduler, indexComp, ..\n    // Note: we dont want to pass in scheduler into comps, we want to keep comp constructor clean,\n    //       therefore we do it here manually for Root Comp, and child comps are managed the same way.\n    this.rootComp.scheduleRendering = this.scheduleRendering.bind( this );\n    this.rootComp.indexComp         = this.indexComp.bind( this );\n    this.rootComp.listBindExternal  = this.listBindExternal;\n\n    // Index Root Comp\n    // Root Comp is an Instance of Component, therefore it is indexed the same way as every other Comp Inst.\n    this.indexComp( this.rootComp );\n\n    // Schedule render the very first time\n    this.rootComp.scheduleRendering( this.rootComp );\n\n    // Inject Root Comp into DOM\n    this.domRoot.insertAdjacentElement( 'afterbegin', this.rootComp.dom );\n  };\n\n  registerBindingBuiltIn() {\n    // Register Global 'gui-click' Built in Event Handler\n    this.registerBinding('gui-click', 'click', function (nameHandler, domNode, evt) {\n      if (typeof this[nameHandler] === 'undefined') {\n        console.warn(`Game GUI: click handler called \"${nameHandler}\" can't be found on the Component (type === '${this.type}', id: ${this.id}).`);\n        return;\n      }\n\n      this[nameHandler].call(this, domNode, 'click', evt);\n    });\n  }\n\n  scheduleRendering (comp) {\n    if ( !comp || !comp.id ) {\n      throw('Non-standard Comp passed in to be scheduled. Comp is either undefined or Comp ID is undefined or null or Empty string etc..');\n    }\n\n    this.isRenderingDue = true;\n    this.listObjIdRenderingScheduled[ comp.id ] = comp;\n  };\n\n  render () {\n    // Skipp rendering if there was no change\n    if (!this.isRenderingDue) {\n      return false;\n    }\n\n    // Render any Comp. that is scheduled\n    for (let idComp in this.listObjIdRenderingScheduled) {\n      let comp = this.listObjIdRenderingScheduled[ idComp ];\n\n      // Recover stored data passed in from Parent Comp previously, and pass it along to Comp Rendering.\n      let dataFromParentPrev = typeof comp.dataFromParentAsStringPrev !== 'undefined' ?\n        JSON.parse( comp.dataFromParentAsStringPrev ) :\n        undefined;\n\n      comp.renderToHtmlAndDomify( dataFromParentPrev );\n      delete this.listObjIdRenderingScheduled[ idComp ];\n    }\n\n    this.isRenderingDue = false;\n\n    // Fire Event Listeners (if any)\n    if( !this.isDOMContentReady ) {\n      this.isDOMContentReady = true;\n      this.fireEventListener('DOMContentReady');\n    }\n    this.fireEventListener('rendered');\n\n    return true;\n  };\n\n  addEventListener( typeEvent, callback ) {\n    this.listObjTypeListEventListener[typeEvent] = this.listObjTypeListEventListener[typeEvent] || [];\n    this.listObjTypeListEventListener[typeEvent].push( {typeEvent, callback} );\n  }\n\n  fireEventListener( typeEvent ) {\n    const listEventListener = this.listObjTypeListEventListener[ typeEvent ];\n\n    if (typeof listEventListener === 'undefined') return;\n\n    for (let indexListEventListener = 0; indexListEventListener < listEventListener.length; indexListEventListener++) {\n      const eventListener = listEventListener[ indexListEventListener ];\n      eventListener.callback( eventListener.typeEvent );\n    }\n  }\n\n  indexComp( comp ) {\n    // Index Comps by Type\n    this.listObjTypeComp[ comp.type ] = this.listObjTypeComp[ comp.type ] || [];\n    this.listObjTypeComp[ comp.type ].push( comp );\n\n    // Check for Duplicate Comp ID\n    if (this.listObjIdComp[ comp.id ]) {\n      throw `Duplicate Comp ID is not allowed. Comp Type \"${comp.type}\", ID in question: ${comp.id}`;\n    }\n\n    // Index Comps by ID\n    this.listObjIdComp[ comp.id ] = comp;\n  };\n\n  getCompByType ( type ) {\n    // todo: feel free to remove remove after 20200101\n    console.warn('Deprecated: \"getCompByType( type )\". Use \"getListCompByType( type )\" instead. \"getCompByType( type )\" will not be supported after end of 2019.');\n    return this.listObjTypeComp[ type ];\n  }\n\n  getListCompByType ( type ) {\n    return this.listObjTypeComp[ type ];\n  }\n\n  getCompById ( id ) {\n    return this.listObjIdComp[ id ];\n  }\n\n  getDomRoot() {\n    return this.domRoot;\n  }\n\n  registerBinding(nameAttribute, typeEvent, callback ) {\n    this.listBindExternal.push( {nameAttribute, typeEvent, callback} );\n  }\n}","import { Component } from \"./Component.js\";\nimport { router } from './Router.js';\n\nexport class Rout extends Component {\n  afterInstantiation ( path ) {\n    router.subToHashChange( path, pathListSub => {\n      this.setState({\n        idChange: this.uid(),\n      });\n    });\n  }\n\n  render( path ) {\n    // Return the Comp that matches the Path provided - Partial Match to the Left works.\n    return router.runIfPathMatch( path, dataInHash =>\n      /*\n        Note: \"this.config\" is the \"CompToRenderWhenPathTriggered\".\n              This is counter intuitive but simplifies the API of a Rout.\n\n        When we include a new Rout\n        ..${this.include(GameGUI.Rout, 'my/path', CompToRenderWhenPathTriggered)}..\n        You can see that \"CompToRenderWhenPathTriggered\" becomes \"this.config\".\n        ..${this.include(ClassComp, dataFromParent, config)}..\n        ClassComp: GameGUI.Rout, dataFromParent: 'my/path', config: CompToRenderWhenPathTriggered\n      */\n      (this.include(this.config, dataInHash))\n    );\n  }\n}\n\nexport default Rout;","export class Router {\n  constructor() {\n    this.listObjRoutParsedCurrent = {};\n    this.listSub                  = [];\n    this.listObjPathListSub       = {}; // note: this is for debugging only\n\n    window.addEventListener(\"hashchange\", this.handlerHashChange.bind( this ), false);\n    this.handlerHashChange();\n  }\n\n  init( gui ) {\n    gui.registerBinding('gui-href', 'click', url => {\n      this.updateHash( url );\n    });\n  }\n\n  getHash( hashInput ) {\n    // Filter off \"#\"\n    // Note: no str.replace(..) cos its slow\n    const hashUpdate = hashInput || location.hash;\n    const hashRawParts = hashUpdate.split('#');\n\n    if ( 2 < hashRawParts.length ) {\n      throw 'Only one \"#\" is allowed in the URL.';\n    }\n\n    return hashRawParts.join('');\n  }\n\n  getListRout( hashInput ) {\n    const hash = this.getHash( hashInput );\n\n    // Single Rout in hash\n    if (hash.indexOf('|') === -1 ) {\n      return [hash];\n\n    // Multiple Routs in hash\n    } else {\n      return hash.split('|')\n                 .filter( rout => rout !== '');\n    }\n  }\n\n  processRout( rout ) {\n    const routProcessed = {\n      id:               null,\n      listObjAttribute: {},\n      path:             null\n    };\n\n    let routRemaining;\n    // Find \"id\" in Rout if any. Not having \"id\" is valid syntax\n    // E.g: \"gui:menu/main\" => id === 'gui', or \"menu/main\" => id === undefined.\n    // Note: \"#\" is already removed from Rout\n    if ( rout.indexOf(':') !== -1 ) {\n      const routListPartById = rout.split(':');\n      routProcessed.id = routListPartById[ 0 ];\n      routRemaining = routListPartById[ 1 ];\n    } else {\n      routProcessed.id = 'noId';\n      routRemaining = rout;\n    }\n\n    // If at least one Attribute provided in Rout\n    if ( routRemaining.indexOf('?') !== -1 ) {\n      const listPartByQuestionmark = routRemaining.split('?');\n      routProcessed.path      = listPartByQuestionmark[0];\n      const strListAttribute  = listPartByQuestionmark[1];\n      const listAttributeStr  = strListAttribute.split('&');\n\n      // Turn Attribute String into Attribute Key Value Pair.\n      // E.g. \"user=Jane\" => listObjAttribute['user'] = 'Jane';\n      // E.g. \"foo\"       => listObjAttribute['foo']  = true;\n      listAttributeStr.forEach(attributeStr => {\n        if ( attributeStr.indexOf('=') !== -1 ) {\n          const listPartByEqualSign = attributeStr.split('=');\n          routProcessed.listObjAttribute[ listPartByEqualSign[0] ] = listPartByEqualSign[1];\n        } else {\n          routProcessed.listObjAttribute[ attributeStr ] = true;\n        }\n      });\n\n    // If NO Attribute is provided in Rout\n    } else {\n      routProcessed.path = routRemaining;\n    }\n\n    return routProcessed;\n  }\n\n  handlerHashChange () {\n    const listRoutStr = this.getListRout();\n    const listObjRoutParsedCurrentUpdate = {};\n    listRoutStr.forEach( routStr => {\n      const routObj = this.processRout( routStr );\n      listObjRoutParsedCurrentUpdate[ routObj.id ] = routObj;\n    });\n\n    this.listObjRoutParsedCurrent = listObjRoutParsedCurrentUpdate;\n\n    this.fireAllSub();\n  }\n\n  subToHashChange ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ) {\n    this.listSub.push( fnToCallIfMatch );\n    this.subToPath ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ); // note: this is for debugging only\n    this.handlerHashChange();\n  }\n\n  subToPath ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ) {\n    const listSub = this.listObjPathListSub[ pathToMatch ] = this.listObjPathListSub[ pathToMatch ] || [];\n    listSub.push( {pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch} );\n  }\n\n  runIfPathMatch ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch, singleActivation ) {\n    let routParsedCurrentMatching;\n\n    // Filter off Path ID from \"pathToMatch\"\n    // E.g. \"somePathId:my/path\" -> pathToMatch = \"my/path\"; idToMatch = 'somePathId'\n    let listPartPath = pathToMatch.split(':');\n    let idToMatch = 1 < listPartPath.length ? listPartPath[0] : 'noId';\n    pathToMatch   = 1 < listPartPath.length ? listPartPath[1] : listPartPath[0];\n\n    // Search\n    // Iterate List of Current Routs/Paths\n    for ( let idListRout in this.listObjRoutParsedCurrent) {\n      const routParsedCurrent = this.listObjRoutParsedCurrent[ idListRout ];\n\n      // If Current Routs/Paths Iter matching Path that we are searching for\n      if (routParsedCurrent.id === idToMatch &&\n          // Note: Partial Matching to Left: Match it only to the left, e.g.: main/setting & main/setting/audio\n          routParsedCurrent.path.indexOf(pathToMatch) === 0\n      ) {\n        routParsedCurrentMatching = routParsedCurrent;\n      }\n    }\n\n    // Matching\n    // If there is a matching Subscriber/Rout\n    if ( routParsedCurrentMatching ) {\n      // If \"fnToCallIfMatch\" should be called once in subsequent matching Paths\n      if ( singleActivation ) {\n        // If Path was inactive up to now\n        if ( !fnToCallIfMatch.isActive ) {\n          fnToCallIfMatch.isActive = true;\n          fnToCallIfMatch.listObjAttribute = routParsedCurrentMatching.listObjAttribute;\n          return fnToCallIfMatch( routParsedCurrentMatching.listObjAttribute );\n\n        // If Path was inactivated by prev path\n        } else {\n          return '';\n        }\n\n      } else {\n        return fnToCallIfMatch( routParsedCurrentMatching.listObjAttribute );\n      }\n\n    // NOT Matching\n    // If there is NO matching Subscriber/Rout, and we have a Callback to call when doesnt match\n    } else if ( typeof fnToCallIfDoesntMatch !== 'undefined' ) {\n      // If Rout was active with prev Path\n      // Note: it makes sure that \"fnToCallIfDoesntMatch\" is called only once\n      if (fnToCallIfMatch.isActive) {\n        fnToCallIfMatch.isActive = false;\n        fnToCallIfDoesntMatch( fnToCallIfMatch.listObjAttribute );\n        fnToCallIfMatch.listObjAttribute = null;\n      }\n\n      return '';\n\n    } else {\n      return '';\n    }\n  }\n\n  fireAllSub () {\n    for (let indexListSub = 0; indexListSub < this.listSub.length; indexListSub++) {\n      const sub = this.listSub[ indexListSub ];\n      sub();\n    }\n  }\n\n  rout ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ) {\n    this.subToHashChange( pathToMatch, () => {\n      this.runIfPathMatch( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch, true );\n    }, fnToCallIfDoesntMatch );\n  }\n\n  updateHash ( hashNew ) {\n    // Collect List of Routs as List of Strings rep. Routs\n    const listRoutStr = this.getListRout( hashNew );\n\n    // Process List of Routs as String to Obj\n    const listObjRoutParsedNew = {};\n    listRoutStr.forEach( routStr => {\n      const routObj = this.processRout( routStr );\n      listObjRoutParsedNew[ routObj.id ] = routObj;\n    });\n\n    // Update List of Hash on record\n    const listObjRoutParsedUpdate = {\n      ...this.listObjRoutParsedCurrent,\n      ...listObjRoutParsedNew\n    };\n\n    const hashUpdated = this.reconstructHash( listObjRoutParsedUpdate );\n    location.hash = hashUpdated;\n  }\n\n  reconstructHash( listObjByIdRoutObj ) {\n    let hashReconstructed = '';\n\n    // Multiple Rout Objects\n    if ( 1 < Object.keys(listObjByIdRoutObj).length ) {\n      let ctrRout = 0;\n\n      // Iterate over the List of Rout Objects\n      for (let idRoutObj in listObjByIdRoutObj) {\n        const routObjIter = listObjByIdRoutObj[ idRoutObj ];\n\n        // Add Rout Divider \"|\" if there are multiple Routs\n        if (ctrRout) hashReconstructed += '|';\n\n        // Reconstruct first part, ID + Path\n        hashReconstructed += routObjIter.id + ':' + routObjIter.path;\n\n        // Reconstruct Attributes from Rout Iter to Hash format, if any\n        hashReconstructed = this.reconstructHashAttributeAll( hashReconstructed, routObjIter );\n\n        ctrRout++;\n      }\n\n    // Single Rout on record\n    } else {\n      const idRoutObj = Object.keys( listObjByIdRoutObj )[ 0 ];\n      const routObj = listObjByIdRoutObj[ idRoutObj ];\n\n      // Reconstruct first part, ID + Path\n      hashReconstructed += routObj.id + ':' + routObj.path;\n\n      // Reconstruct Attributes from Rout to Hash format, if any. E.g.: ..bar=2&foo&..\n      hashReconstructed = this.reconstructHashAttributeAll( hashReconstructed, routObj );\n    }\n\n    return hashReconstructed;\n  }\n\n  reconstructHashAttributeAll( hashReconstructed, routObj ) {\n    // If Rout Iter contains Attributes\n    if ( 0 < Object.keys(routObj.listObjAttribute).length ) {\n      hashReconstructed += '?';\n      let ctrAttribute = 0;\n\n      // Iterate over Rout Attributes\n      Object.keys( routObj.listObjAttribute ).forEach( attributeKey => {\n        const attributeValue = routObj.listObjAttribute[ attributeKey ];\n\n        // Add Attribute Divider \"&\" if there are multiple Attributes\n        if ( 0 < ctrAttribute ) hashReconstructed += '&';\n\n        // If Boolean Attribute, e.g.: ..bar=2&foo&.. => foo === true\n        if ( typeof attributeValue === 'boolean' ) {\n          hashReconstructed += attributeKey;\n\n          // Any type of Attribute but Boolean\n        } else {\n          hashReconstructed += attributeKey + '=' + routObj.listObjAttribute[ attributeKey ];\n        }\n\n        ctrAttribute++;\n      });\n    }\n\n    return hashReconstructed;\n  }\n}\n\n// Export a Single Router Instance, because we only want one Router that is aware of all the Routs\nexport const router = new Router();","import { GameGUI }    from './GameGUI.js';\r\n\r\nexport { Component }  from './Component';\r\nexport { router }     from './router.js'\r\nexport { Rout }       from './Rout.js'\r\n\r\nexport default GameGUI;","export class Router {\n  constructor() {\n    this.listObjRoutParsedCurrent = {};\n    this.listSub                  = [];\n    this.listObjPathListSub       = {}; // note: this is for debugging only\n\n    window.addEventListener(\"hashchange\", this.handlerHashChange.bind( this ), false);\n    this.handlerHashChange();\n  }\n\n  init( gui ) {\n    gui.registerBinding('gui-href', 'click', url => {\n      this.updateHash( url );\n    });\n  }\n\n  getHash( hashInput ) {\n    // Filter off \"#\"\n    // Note: no str.replace(..) cos its slow\n    const hashUpdate = hashInput || location.hash;\n    const hashRawParts = hashUpdate.split('#');\n\n    if ( 2 < hashRawParts.length ) {\n      throw 'Only one \"#\" is allowed in the URL.';\n    }\n\n    return hashRawParts.join('');\n  }\n\n  getListRout( hashInput ) {\n    const hash = this.getHash( hashInput );\n\n    // Single Rout in hash\n    if (hash.indexOf('|') === -1 ) {\n      return [hash];\n\n    // Multiple Routs in hash\n    } else {\n      return hash.split('|')\n                 .filter( rout => rout !== '');\n    }\n  }\n\n  processRout( rout ) {\n    const routProcessed = {\n      id:               null,\n      listObjAttribute: {},\n      path:             null\n    };\n\n    let routRemaining;\n    // Find \"id\" in Rout if any. Not having \"id\" is valid syntax\n    // E.g: \"gui:menu/main\" => id === 'gui', or \"menu/main\" => id === undefined.\n    // Note: \"#\" is already removed from Rout\n    if ( rout.indexOf(':') !== -1 ) {\n      const routListPartById = rout.split(':');\n      routProcessed.id = routListPartById[ 0 ];\n      routRemaining = routListPartById[ 1 ];\n    } else {\n      routProcessed.id = 'noId';\n      routRemaining = rout;\n    }\n\n    // If at least one Attribute provided in Rout\n    if ( routRemaining.indexOf('?') !== -1 ) {\n      const listPartByQuestionmark = routRemaining.split('?');\n      routProcessed.path      = listPartByQuestionmark[0];\n      const strListAttribute  = listPartByQuestionmark[1];\n      const listAttributeStr  = strListAttribute.split('&');\n\n      // Turn Attribute String into Attribute Key Value Pair.\n      // E.g. \"user=Jane\" => listObjAttribute['user'] = 'Jane';\n      // E.g. \"foo\"       => listObjAttribute['foo']  = true;\n      listAttributeStr.forEach(attributeStr => {\n        if ( attributeStr.indexOf('=') !== -1 ) {\n          const listPartByEqualSign = attributeStr.split('=');\n          routProcessed.listObjAttribute[ listPartByEqualSign[0] ] = listPartByEqualSign[1];\n        } else {\n          routProcessed.listObjAttribute[ attributeStr ] = true;\n        }\n      });\n\n    // If NO Attribute is provided in Rout\n    } else {\n      routProcessed.path = routRemaining;\n    }\n\n    return routProcessed;\n  }\n\n  handlerHashChange () {\n    const listRoutStr = this.getListRout();\n    const listObjRoutParsedCurrentUpdate = {};\n    listRoutStr.forEach( routStr => {\n      const routObj = this.processRout( routStr );\n      listObjRoutParsedCurrentUpdate[ routObj.id ] = routObj;\n    });\n\n    this.listObjRoutParsedCurrent = listObjRoutParsedCurrentUpdate;\n\n    this.fireAllSub();\n  }\n\n  subToHashChange ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ) {\n    this.listSub.push( fnToCallIfMatch );\n    this.subToPath ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ); // note: this is for debugging only\n    this.handlerHashChange();\n  }\n\n  subToPath ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ) {\n    const listSub = this.listObjPathListSub[ pathToMatch ] = this.listObjPathListSub[ pathToMatch ] || [];\n    listSub.push( {pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch} );\n  }\n\n  runIfPathMatch ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch, singleActivation ) {\n    let routParsedCurrentMatching;\n\n    // Filter off Path ID from \"pathToMatch\"\n    // E.g. \"somePathId:my/path\" -> pathToMatch = \"my/path\"; idToMatch = 'somePathId'\n    let listPartPath = pathToMatch.split(':');\n    let idToMatch = 1 < listPartPath.length ? listPartPath[0] : 'noId';\n    pathToMatch   = 1 < listPartPath.length ? listPartPath[1] : listPartPath[0];\n\n    // Search\n    // Iterate List of Current Routs/Paths\n    for ( let idListRout in this.listObjRoutParsedCurrent) {\n      const routParsedCurrent = this.listObjRoutParsedCurrent[ idListRout ];\n\n      // If Current Routs/Paths Iter matching Path that we are searching for\n      if (routParsedCurrent.id === idToMatch &&\n          // Note: Partial Matching to Left: Match it only to the left, e.g.: main/setting & main/setting/audio\n          routParsedCurrent.path.indexOf(pathToMatch) === 0\n      ) {\n        routParsedCurrentMatching = routParsedCurrent;\n      }\n    }\n\n    // Matching\n    // If there is a matching Subscriber/Rout\n    if ( routParsedCurrentMatching ) {\n      // If \"fnToCallIfMatch\" should be called once in subsequent matching Paths\n      if ( singleActivation ) {\n        // If Path was inactive up to now\n        if ( !fnToCallIfMatch.isActive ) {\n          fnToCallIfMatch.isActive = true;\n          fnToCallIfMatch.listObjAttribute = routParsedCurrentMatching.listObjAttribute;\n          return fnToCallIfMatch( routParsedCurrentMatching.listObjAttribute );\n\n        // If Path was inactivated by prev path\n        } else {\n          return '';\n        }\n\n      } else {\n        return fnToCallIfMatch( routParsedCurrentMatching.listObjAttribute );\n      }\n\n    // NOT Matching\n    // If there is NO matching Subscriber/Rout, and we have a Callback to call when doesnt match\n    } else if ( typeof fnToCallIfDoesntMatch !== 'undefined' ) {\n      // If Rout was active with prev Path\n      // Note: it makes sure that \"fnToCallIfDoesntMatch\" is called only once\n      if (fnToCallIfMatch.isActive) {\n        fnToCallIfMatch.isActive = false;\n        fnToCallIfDoesntMatch( fnToCallIfMatch.listObjAttribute );\n        fnToCallIfMatch.listObjAttribute = null;\n      }\n\n      return '';\n\n    } else {\n      return '';\n    }\n  }\n\n  fireAllSub () {\n    for (let indexListSub = 0; indexListSub < this.listSub.length; indexListSub++) {\n      const sub = this.listSub[ indexListSub ];\n      sub();\n    }\n  }\n\n  rout ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ) {\n    this.subToHashChange( pathToMatch, () => {\n      this.runIfPathMatch( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch, true );\n    }, fnToCallIfDoesntMatch );\n  }\n\n  updateHash ( hashNew ) {\n    // Collect List of Routs as List of Strings rep. Routs\n    const listRoutStr = this.getListRout( hashNew );\n\n    // Process List of Routs as String to Obj\n    const listObjRoutParsedNew = {};\n    listRoutStr.forEach( routStr => {\n      const routObj = this.processRout( routStr );\n      listObjRoutParsedNew[ routObj.id ] = routObj;\n    });\n\n    // Update List of Hash on record\n    const listObjRoutParsedUpdate = {\n      ...this.listObjRoutParsedCurrent,\n      ...listObjRoutParsedNew\n    };\n\n    const hashUpdated = this.reconstructHash( listObjRoutParsedUpdate );\n    location.hash = hashUpdated;\n  }\n\n  reconstructHash( listObjByIdRoutObj ) {\n    let hashReconstructed = '';\n\n    // Multiple Rout Objects\n    if ( 1 < Object.keys(listObjByIdRoutObj).length ) {\n      let ctrRout = 0;\n\n      // Iterate over the List of Rout Objects\n      for (let idRoutObj in listObjByIdRoutObj) {\n        const routObjIter = listObjByIdRoutObj[ idRoutObj ];\n\n        // Add Rout Divider \"|\" if there are multiple Routs\n        if (ctrRout) hashReconstructed += '|';\n\n        // Reconstruct first part, ID + Path\n        hashReconstructed += routObjIter.id + ':' + routObjIter.path;\n\n        // Reconstruct Attributes from Rout Iter to Hash format, if any\n        hashReconstructed = this.reconstructHashAttributeAll( hashReconstructed, routObjIter );\n\n        ctrRout++;\n      }\n\n    // Single Rout on record\n    } else {\n      const idRoutObj = Object.keys( listObjByIdRoutObj )[ 0 ];\n      const routObj = listObjByIdRoutObj[ idRoutObj ];\n\n      // Reconstruct first part, ID + Path\n      hashReconstructed += routObj.id + ':' + routObj.path;\n\n      // Reconstruct Attributes from Rout to Hash format, if any. E.g.: ..bar=2&foo&..\n      hashReconstructed = this.reconstructHashAttributeAll( hashReconstructed, routObj );\n    }\n\n    return hashReconstructed;\n  }\n\n  reconstructHashAttributeAll( hashReconstructed, routObj ) {\n    // If Rout Iter contains Attributes\n    if ( 0 < Object.keys(routObj.listObjAttribute).length ) {\n      hashReconstructed += '?';\n      let ctrAttribute = 0;\n\n      // Iterate over Rout Attributes\n      Object.keys( routObj.listObjAttribute ).forEach( attributeKey => {\n        const attributeValue = routObj.listObjAttribute[ attributeKey ];\n\n        // Add Attribute Divider \"&\" if there are multiple Attributes\n        if ( 0 < ctrAttribute ) hashReconstructed += '&';\n\n        // If Boolean Attribute, e.g.: ..bar=2&foo&.. => foo === true\n        if ( typeof attributeValue === 'boolean' ) {\n          hashReconstructed += attributeKey;\n\n          // Any type of Attribute but Boolean\n        } else {\n          hashReconstructed += attributeKey + '=' + routObj.listObjAttribute[ attributeKey ];\n        }\n\n        ctrAttribute++;\n      });\n    }\n\n    return hashReconstructed;\n  }\n}\n\n// Export a Single Router Instance, because we only want one Router that is aware of all the Routs\nexport const router = new Router();"],"sourceRoot":""}