{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./src/Component.js","webpack://[name]/./src/GameGUI.js","webpack://[name]/./src/Rout.js","webpack://[name]/./src/Router.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAO;AACP,2BAA2B,aAAa,qBAAqB;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,UAAU;AACxD;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oDAAoD,SAAS,oBAAoB,aAAa,eAAe,SAAS;;AAEtH;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,uCAAuC;AACzE;;AAEA;AACA;AACA,wDAAwD,YAAY,+CAA+C,UAAU,SAAS,QAAQ;AAC9I;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,uDAAuD;AACjG;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2EAA2E,SAAS,yBAAyB,iBAAiB,iBAAiB,SAAS;AACxJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEe,wEAAS,E;;;;;;;;;;;;AC9RxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wCAA8B;;AAEvB;AACP;AACA,kBAAkB,+CAAM;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kCAAkC,4CAA4C;AAC9E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,UAAU,qBAAqB,QAAQ;AACnG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAE4B;AACH;AACF;AACL;AACH,sEAAO,E;;;;;;;;;;;;ACtKtB;AAAA;AAAA;AAAA;AAAoC;AACC;;AAE9B,mBAAmB,kDAAS;AACnC;AACA;AACA,IAAI,+CAAa;AACjB;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA,WAAW,+CAAa;AACxB;AACA;AACA;AACA,C;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mHAAmH;;AAE5G;AACP;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,iDAAiD;AAC/E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B,oCAAoC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEuB;AAChB;AACQ,qEAAM,E","file":"GameGUI.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GameGUI\"] = factory();\n\telse\n\t\troot[\"GameGUI\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/GameGUI.js\");\n","export class Component {\n  constructor ( option = {}, config = {}, dataFromParent = {} ) {\n    // Note: \"option\" and \"config\" are registered at first include when Comp is instantiated.\n    //       These props wont be updated even if then change at subsequent rerenderings.\n    this.option                     = option;\n    this.config                     = config;\n\n    this.id                         = typeof config.id !== 'undefined' ? config.id : this.uid();\n    this.type                       = this.getTypeOfComp( this );\n    this.classNameInHtml            = this.camelCaseToSnakeCase( this.type );\n    this.dom                        = this.createDomRepresentation();\n                                      // Note: \"this.dom\" this is a wrapper element. The output of \"this.render(..)\"\n                                      // is placed inside this wrapper. The wrapper is created only once at\n                                      // Comp instantiation, but its content is created from scratch, then injected at\n                                      // every Comp Render call - at this.render(..).\n    this.listObjCompChildByType     = {}; // Cache previously rendered Comps here.\n    this.html                       = '';\n    this.ctrChildByType             = {};\n\n    this.state                      = {};\n    this.isStateUpdated             = false; // when Comp State is updated, this is set to true till\n                                             // State Change is rendered to HTML/DOM\n    this.dataFromParentAsStringPrev = undefined;\n\n    // Run Life Cycle Method if defined on Comp Instance\n    if  (typeof this.afterInstantiation !== 'undefined') {\n      this.afterInstantiation( dataFromParent );\n    }\n  }\n\n  getTypeOfComp ( comp ) {\n    // Issue: Babel transpiles MyCompName to MyCompName_ImportedCompName. We are filtering this off here.\n    //        If we ignored this, the code wouldn't be compilable.\n    const type = Object.getPrototypeOf(comp).constructor.name;\n    const listTypePart = type.split('_');\n    return listTypePart[ listTypePart.length -1 ];\n  }\n\n  createDomRepresentation () {\n    const domElement = document.createElement('div');\n    domElement.classList.add( this.classNameInHtml );\n    domElement.setAttribute('id', this.id);\n\n    return domElement;\n  }\n\n  render() {\n    return `<span>Placeholder text for Comp ${this.type}</span>`;\n  }\n\n  /**\n   * Syntax: ..${this.include(ClassComp, dataFromParent, config)}\n   * Use \"include\" inside any \"render\" method to embed Comps inside Comps.\n   * It returns a Placeholder HTML Snippet, that is included in the Parent Comps DOM till\n   * the next Game GUI Render Event will call \"renderToHtmlAndDomify\" on Parent Comp,\n   * when all Placeholder HTML Snippet will be replaced with the relevant Included Comps DOM.\n   * @param ClassComp\n   * @param dataFromParent\n   * @param config\n   * @returns {string|*}\n   */\n  include ( ClassComp, dataFromParent, config ) {\n    // If Smart Comp (Class)\n    if ( ClassComp.prototype instanceof Component ) {\n      const typeComp = ClassComp.name;\n      const ctrChild = this.ctrChildByType[ typeComp ] = typeof this.ctrChildByType[ typeComp ] === 'undefined' ?\n                                                            0                                                   :\n                                                            ++this.ctrChildByType[ typeComp ];\n\n      const idCompChild = (config && typeof config.id !== 'undefined') ? config.id : ctrChild;\n      this.listObjCompChildByType[ typeComp ] = this.listObjCompChildByType[ typeComp ] || {};\n      let compChild = this.listObjCompChildByType[ typeComp ][ idCompChild ];\n\n      // Create new instance of Comp only if it hasn't been created yet\n      if ( typeof compChild === 'undefined' ) {\n        compChild = this.listObjCompChildByType[ typeComp ][ idCompChild ] = new ClassComp( this.option, config, dataFromParent );\n        // Note: \"option\" is a global in the scope of Game GUI, therefore we pass it along to every Child Comp,\n        //       hence making it available in every Comp through \"this.option\".\n        //       \"config\" and \"dataFromParent\" on the other hand are specific to each Comp,\n        //       therefore we pass in a new one at every include, unlike we do with \"option\".\n        //       \"option\" and \"config\" both are registered when the Comp is instantiated (at first inclusion),\n        //       then we never update them again, even if we include them multiple times with different config,\n        //       that won't effect the original config. Therefore, you are welcome to modify it (e.g. in constructor)\n        //       after Comp is instantiated, those modifications will remain.\n        //       \"dataFromParent\" on the other hand will be update and passed in to \"render\" method,\n        //       every time the Parent Comp is re-rendered.\n\n        // Hook up Game GUI Methods: scheduler, indexComp\n        // Note: make sure you dont bind this, you need scheduler to resolve to ui framework,\n        //       and not to comp instance.\n        //       These hooked up methods wont be called at construction time,\n        //       therefore there is no problem hooking them up after Comp Instantiation.\n        compChild.scheduleRendering = this.scheduleRendering;\n        compChild.indexComp         = this.indexComp;\n\n        // Index Comp right after its created and even before its rendered.\n        // Note: The rendering of Root Comp will trigger the indexing of all Sub Comps.\n        this.indexComp( compChild );\n      }\n\n      compChild.renderToHtmlAndDomify( dataFromParent );\n      // Note: \"dataFromParent\" from Parent Comp is updated in Child Comp by \"include\", but\n      //       \"config\" and \"option\" are not, they are passed in only at first inclusion (at Comp Instantiation)\n\n      const idFromConfig = (config && typeof config.id !== 'undefined') ? config.id : '';\n\n      return `<div class=\"comp-placeholder\" type=\"${typeComp}\" id-from-config=\"${idFromConfig}\" ctr-child=\"${ctrChild}\">placeholder text</div>`;\n\n    // If Dumb Comp (Function)\n    } else {\n      return ClassComp( dataFromParent, this.option );\n    }\n  };\n\n  renderToHtmlAndDomify ( dataFromParent ) {\n    // Optimise Rendering to HTML\n    // Note: Comp HTML Representation can change one of three ways:\n    //       A) Data Passed in from Parent Comp has changed\n    //       B) State has changed\n    //       C) HTML Representation of Comp has never been created before, therefore\n    //          what ever we render will be different from current HTML Representation of the Comp.\n\n    const renderBecauseDataPassedInChanged = this.isRenderBecauseDataPassedInChanged ( dataFromParent );\n\n    // Don't skip if HTML representation of Comp has never been rendered yet.\n    // Skip only if Data Passed In From Parent Comp hasn't changed and the sate of the Comp hasn't changed either\n    if (this.html !== '' &&\n        !renderBecauseDataPassedInChanged &&\n        !this.isStateUpdated\n    ) {\n      return false;\n    }\n\n    // Note: Record of Data Passed In From Parent has already been updated by \"isRenderBecauseDataPassedInChanged\"\n    //       because we have already stringified Data Passed In From Parent in \"isRenderBecauseDataPassedInChanged\",\n    //       therefore we don't want to do it twice, efficiency\n    // !! this.dataFromParentAsStringPrev = JSON.stringify( dataFromParent );\n\n    // Render to HTML String\n    this.ctrChildByType = {};\n    var htmlNewRender   = this.render( dataFromParent );\n    this.isStateUpdated = false; // Updated Comp State is rendered to HTML/DOM at \"this.render(..)\", so we reset it here\n\n    // Skip ReDomify if Comp Shallow Render looks the same\n    // Note: if the Data Passed In From Parent has changed and/or Comp State has changed,\n    //       that doesnt necessarily mean that the rendered html is different\n    if ( htmlNewRender === this.html ) {\n      return false;\n    }\n\n    this.html = htmlNewRender;\n\n    // DOMify HTML String\n    this.dom.innerHTML = this.html;\n\n    // Do predefined bindings automatically right after DOM is ready\n    this.doBind();\n\n    // Run Life Cycle Method if defined on Comp Instance\n    if  (typeof this.afterRender !== 'undefined') {\n      this.afterRender();\n    }\n\n    // Inject Child Comps if any\n    this.replaceCompPlaceholderAll( this.dom );\n\n    return true;\n  }\n\n  isRenderBecauseDataPassedInChanged ( dataFromParent ) {\n    const isUndefinedDataFromParentAsStringPrev = typeof this.dataFromParentAsStringPrev === 'undefined';\n    const isUndefinedDataFromParentAsString     = typeof dataFromParent                  === 'undefined';\n\n    // Scenario 1)  prev === undefined && passed === undefined --> DON'T RENDER\n    if ( isUndefinedDataFromParentAsStringPrev &&\n         isUndefinedDataFromParentAsString\n    ) {\n      return false;\n    }\n\n    const dataFromParentAsString = JSON.stringify( dataFromParent );\n\n    // Scenario 2)  prev === undefined && passed !== undefined --> RENDER\n    if ( isUndefinedDataFromParentAsStringPrev &&\n         !isUndefinedDataFromParentAsString\n    ) {\n      this.dataFromParentAsStringPrev = dataFromParentAsString;\n      return true;\n    }\n\n    // Scenario 3)  prev !== undefined && passed === undefined --> RENDER\n    if ( !isUndefinedDataFromParentAsStringPrev &&\n         isUndefinedDataFromParentAsString\n    ) {\n      this.dataFromParentAsStringPrev = dataFromParentAsString;\n      return true;\n    }\n\n    // Scenario 4)  prev !== undefined && passed !== undefined --> COMPARE\n    if ( !isUndefinedDataFromParentAsStringPrev &&\n         !isUndefinedDataFromParentAsString\n    ) {\n      // Compare / same       --> DON'T RENDER\n      if ( this.dataFromParentAsStringPrev === dataFromParentAsString) {\n        return false;\n\n      // Compare / different  --> RENDER\n      } else {\n        this.dataFromParentAsStringPrev = dataFromParentAsString;\n        return true;\n      }\n    }\n\n    console.error('Something unexpected happened o_0?');\n    debugger;\n  }\n\n  doBind () {\n    // ui-click | Do click handler bindings automatically right after rendering\n    // Note: Binding happens before Child Comps are injected so Encapsulation is unharmed\n    const listNodeBtn = this.dom.querySelectorAll('[ui-click]');\n    for (let indexListNodeBtn = 0; indexListNodeBtn < listNodeBtn.length; indexListNodeBtn++) {\n      const nodeBtn = listNodeBtn[ indexListNodeBtn ];\n\n      const nameHandler = nodeBtn.getAttribute('ui-click');\n      if (typeof this[nameHandler] === 'undefined') {\n        console.warn(`Game GUI: click handler called \"${nameHandler}\" can't be found on the Component (type === '${this.type}', id: ${this.id}).`);\n        continue;\n      }\n\n      nodeBtn.addEventListener('click', this[nameHandler].bind(this), false);\n    }\n  }\n\n  replaceCompPlaceholderAll () {\n    // Get a list of all Placeholder Child Component\n    var nodeListPlaceholder = this.dom.querySelectorAll('.comp-placeholder');\n\n    // Iterate over all Placeholder Child Comps and replace them with Comp DOM\n    for (let indexNodeListPlaceholder = 0; indexNodeListPlaceholder < nodeListPlaceholder.length; indexNodeListPlaceholder++) {\n      let dPlaceholder = nodeListPlaceholder[ indexNodeListPlaceholder ];\n\n      const typeComp          = dPlaceholder.getAttribute('type');\n      const idCompFromConfig  = dPlaceholder.getAttribute('id-from-config');\n      const ctrChild          = dPlaceholder.getAttribute('ctr-child');\n\n      const idCompChild = !!idCompFromConfig ? idCompFromConfig : ctrChild;\n      const compChild   = this.listObjCompChildByType[ typeComp ][ idCompChild ];\n\n      if (!compChild) {\n        const message  = `Warning: Component can't be found: typeComp===\"${typeComp}\", idCompFromConfig===\"${idCompFromConfig}\", ctrChild===\"${ctrChild}\". State of Cached Comps: `;\n        console.warn(message, JSON.stringify(this.listObjCompChildByType));\n        continue;\n      }\n\n      compChild.dom = dPlaceholder.insertAdjacentElement('beforebegin', compChild.dom);\n      dPlaceholder.parentNode.removeChild(dPlaceholder);\n    }\n  };\n\n  getState () {\n    return this.state;\n  };\n\n  setState ( stateNew ) {\n    this.state = stateNew;\n    this.isStateUpdated = true;\n\n    if ( typeof this.scheduleRendering !== 'undefined' ) {\n      this.scheduleRendering( this );\n    }\n  };\n\n\n  // # Utility\n  // # #######\n\n  camelCaseToSnakeCase (str) {\n    return str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase()\n  }\n\n  uid () {\n    return Date.now()+''+Math.round(Math.random() * 100000);\n  }\n}\n\nexport default Component;","import router from './Router';\n\nexport class GameGUI {\n  constructor(RootComp, selectorGuiRoot, option, configRootComp) {\n    this.router = router;\n\n    // Reg Root Comp automatically if requirements are fulfilled\n    // Note: don't run it by default, you may want to control the steps.\n    if (typeof RootComp === 'undefined' ||\n        typeof selectorGuiRoot === 'undefined'\n    ) {\n      return;\n    }\n\n    this.init(option);\n    this.regRootComp(RootComp, selectorGuiRoot, configRootComp);\n\n    // Call the very first render ASAP\n    // Note:  Otherwise you might see a brief flash\n    //        Running render in the constructor means, all includes will be called recursively,\n    //        therefore all Comp / SubC omp Instantiation will happen sequentially when Game GUI is Instantiated.\n    //        That said, all Comps are indexed and ready to be accessed right after Game GUI Instantiation.\n    this.render();\n  };\n\n  init(option = {}) {\n    this.optionDefault = {\n      fps: 60,\n    };\n\n    // Should compose option from default options, and options passed in at construction\n    this.option = {\n      ...this.optionDefault,\n      ...option,\n    };\n\n    this.isRenderingDue = false;\n    this.listObjIdRenderingScheduled = {};\n\n    // Indexed list of all rendered Comps\n    this.listObjTypeComp = {};\n    this.listObjIdComp = {};\n\n    // Store and call from the list of callbacks passed in to be run right after rendering(s) is complete.\n    this.listOnRender = [];\n\n    // Note: Don't worry about calling render 60 times a sec,\n    // render method start with \"if(!this.isRenderingDue ) return;\"\n    this.tokenUiRender;\n    if (typeof interval !== 'undefined') {\n      this.tokenUiRender = interval.setInterval(this.render.bind(this), Math.floor(1000/this.option.fps));\n    } else {\n      this.tokenUiRender = setInterval(this.render.bind(this), Math.floor(1000/this.option.fps));\n    }\n  }\n\n  regRootComp ( RootComp, selectorGuiRoot, configRootComp ) {\n    // Get UI Root\n    this.domRoot = document.querySelector( selectorGuiRoot );\n\n    // Throws if Root DOM Element doesn't exist\n    if (this.domRoot === null) {\n      throw('ERROR: DOM Root can\\'t be found by using the provided selector: ' + selectorGuiRoot);\n    }\n\n    // Instantiate Root Comp\n    this.rootComp = new RootComp( this.option, configRootComp );\n\n    // Hook up Game GUI Methods: scheduler, indexComp\n    // Note: we dont want to pass in scheduler into comps, we want to keep comp constructor clean,\n    //       therefore we do it here manually for Root Comp, and child comps are managed the same way.\n    this.rootComp.scheduleRendering = this.scheduleRendering.bind( this );\n    this.rootComp.indexComp         = this.indexComp.bind( this );\n\n    // Index Root Comp\n    // Root Comp is an Instance of Component, therefore it is indexed the same way as every other Comp Inst.\n    this.indexComp( this.rootComp );\n\n    // Schedule render the very first time\n    this.rootComp.scheduleRendering( this.rootComp );\n\n    // Inject Root Comp into DOM\n    this.domRoot.insertAdjacentElement( 'afterbegin', this.rootComp.dom );\n  };\n\n  scheduleRendering (comp) {\n    if ( !comp || !comp.id ) {\n      throw('Non-standard Comp passed in to be scheduled. Comp is either undefined or Comp ID is undefined or null or Empty string etc..');\n    }\n\n    this.isRenderingDue = true;\n    this.listObjIdRenderingScheduled[ comp.id ] = comp;\n  };\n\n  render () {\n    // Skipp rendering if there was no change\n    if (!this.isRenderingDue) {\n      return false;\n    }\n\n    // Render any Comp. that is scheduled\n    for (let idComp in this.listObjIdRenderingScheduled) {\n      let comp = this.listObjIdRenderingScheduled[ idComp ];\n\n      // Recover stored data passed in from Parent Comp previously, and pass it along to Comp Rendering.\n      let dataFromParentPrev = typeof comp.dataFromParentAsStringPrev !== 'undefined' ?\n        JSON.parse( comp.dataFromParentAsStringPrev ) :\n        undefined;\n\n      comp.renderToHtmlAndDomify( dataFromParentPrev );\n      delete this.listObjIdRenderingScheduled[ idComp ];\n    }\n\n    this.isRenderingDue = false;\n\n    // Call all the render event handlers passed in externally\n    if( 0 < this.listOnRender.length ) {\n      for(let indexListOnRender=0; indexListOnRender<this.listOnRender.length; indexListOnRender++) {\n        this.listOnRender[ indexListOnRender ]();\n      }\n    }\n\n    return true;\n  };\n\n  onRender ( callback ) {\n    this.listOnRender.push( callback );\n  }\n\n  indexComp( comp ) {\n    // Index Comps by Type\n    this.listObjTypeComp[ comp.type ] = this.listObjTypeComp[ comp.type ] || [];\n    this.listObjTypeComp[ comp.type ].push( comp );\n\n    // Check for Duplicate Comp ID\n    if (this.listObjIdComp[ comp.id ]) {\n      throw `Duplicate Comp ID is not allowed. Comp Type \"${comp.type}\", ID in question: ${comp.id}`;\n    }\n\n    // Index Comps by ID\n    this.listObjIdComp[ comp.id ] = comp;\n  };\n\n  getCompByType ( type ) {\n    // todo: feel free to remove remove after 20200101\n    console.warn('Deprecated: \"getCompByType( type )\". Use \"getListCompByType( type )\" instead. \"getCompByType( type )\" will not be supported after end of 2019.');\n    return this.listObjTypeComp[ type ];\n  }\n\n  getListCompByType ( type ) {\n    return this.listObjTypeComp[ type ];\n  }\n\n  getCompById ( id ) {\n    return this.listObjIdComp[ id ];\n  }\n\n  getDomRoot() {\n    return this.domRoot;\n  }\n}\n\nexport * from './Component';\nexport * from './Router';\nexport * from './Rout';\nexport { router };\nexport default GameGUI;","import Component from \"./Component\";\nimport gameGUIRouter from './Router';\n\nexport class Rout extends Component {\n  afterInstantiation ( path ) {\n    console.log('----- dataFromParent (afterInstantiation)', path);\n    gameGUIRouter.subToHashChange(path, pathListSub => {\n      this.setState({\n        idChange: this.uid(),\n      });\n    });\n  }\n\n  render( path ) {\n    console.log('----- dataFromParent (render)', path);\n\n    return gameGUIRouter.runIfPathMatch(path, (attrib) =>\n      this.include(this.config, attrib)\n    );\n  }\n}","// todo: make ID as optional specification for routs, otherweise they r useless ..maybe thats okay\n// todo: make sure you can have multiple routs matching the same path \"this.listObjPathListSub[ pathToMatch ] = fn;\"\n\nexport class Router {\n  constructor() {\n    this.listRoutParsedCurrent  = [];\n    this.listSub                = [];\n    this.listObjPathListSub     = {}; // note: this is for debugging only\n\n    window.addEventListener(\"hashchange\", this.handlerHashChange.bind( this ), false);\n    this.handlerHashChange();\n  }\n\n  getHash() {\n    // Filter off \"#\"\n    // Note: no str.replace(..) cos its slow\n    const hashRawParts = location.hash.split('#');\n\n    if ( 2 < hashRawParts.length ) {\n      throw 'Only one \"#\" is allowed in the URL.';\n    }\n\n    return hashRawParts.join('');\n  }\n\n  getListRout() {\n    const hash = this.getHash();\n\n    // Single Rout in hash\n    if (hash.indexOf('@') === -1 ) {\n      return [hash];\n    } else {\n      return hash.split('@')\n                 .filter( rout => rout !== '');\n    }\n  }\n\n  processRout( rout ) {\n    let id,\n        routRemaining;\n    if ( rout.indexOf(':') !== -1 ) {\n      const routListPartById = rout.split(':');\n      id = routListPartById[ 0 ];\n      routRemaining = routListPartById[ 1 ];\n    } else {\n      routRemaining = rout;\n    }\n\n    let listObjAttribute,\n        path;\n    if ( routRemaining.indexOf('?') !== -1 ) {\n      const listPartByQuestionmark = routRemaining.split('?');\n      const strListAttribute  = listPartByQuestionmark[1];\n      const listAttributeStr  = strListAttribute.split('&');\n      path                    = listPartByQuestionmark[0];\n\n      listObjAttribute = {};\n      listAttributeStr.forEach(attributeStr => {\n        if ( attributeStr.indexOf('=') !== -1 ) {\n          const listPartByEqualSign = attributeStr.split('=');\n          listObjAttribute[ listPartByEqualSign[0] ] = listPartByEqualSign[1];\n        } else {\n          listObjAttribute[attributeStr] = true;\n        }\n      });\n\n    } else {\n      path = routRemaining;\n    }\n\n    return {\n      id,\n      listObjAttribute,\n      path,\n    }\n  }\n\n  handlerHashChange () {\n    const listRoutStr = this.getListRout();\n    this.listRoutParsedCurrent = listRoutStr.map(rout => this.processRout(rout));\n    // ...\n    this.fireAllSub();\n    console.log('this.listRoutParsedCurrent:', this.listRoutParsedCurrent);\n  }\n\n  subToHashChange ( pathToMatch, fn ) {\n    this.listSub.push( fn );\n    this.subToPath ( pathToMatch, fn ); // note: this is for debugging only\n  }\n\n  subToPath ( pathToMatch, fn ) {\n    const listSub = this.listObjPathListSub[ pathToMatch ] = this.listObjPathListSub[ pathToMatch ] || [];\n    listSub.push( fn );\n  }\n\n  runIfPathMatch ( pathToMatch, fn ) {\n    for ( let indexListRout=0; indexListRout<this.listRoutParsedCurrent.length; indexListRout++ ) {\n      const routParsedCurrent = this.listRoutParsedCurrent[ indexListRout ];\n\n      if ( routParsedCurrent.path.indexOf(pathToMatch) === 0 ) {\n        return fn( routParsedCurrent.listObjAttribute );\n      }\n    }\n\n    return '';\n  }\n\n  fireAllSub () {\n    for (let indexListSub = 0; indexListSub < this.listSub.length; indexListSub++) {\n      const sub = this.listSub[ indexListSub ];\n      sub();\n    }\n  }\n\n  rout ( pathToMatch, fnToCallIfMatch ) {\n    this.subToHashChange( pathToMatch, () => {\n      this.runIfPathMatch( pathToMatch, fnToCallIfMatch );\n    });\n  }\n\n  // fireAllSubOld() {\n  //   for (let pathListSub in this.listObjPathListSub) {\n  //     const listSub = this.listObjPathListSub[ pathListSub ];\n  //     for (let indexListSub = 0; indexListSub < listSub.length; indexListSub++) {\n  //       const sub = listSub[ indexListSub ];\n  //       sub( pathListSub );\n  //     }\n  //   }\n  // }\n}\n\nexport * from './Rout';\nexport const router = new Router();\nexport default router;"],"sourceRoot":""}