{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./src/Component.js","webpack://[name]/./src/GameGUI.js","webpack://[name]/./src/Rout.js","webpack://[name]/./src/index.js","webpack://[name]/./src/router.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAO;AACP,2BAA2B,aAAa,qBAAqB;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA,4CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,UAAU;AACxD;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oDAAoD,SAAS,oBAAoB,aAAa,eAAe,SAAS;;AAEtH;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,sDAAsD;AAC/F;;AAEA;AACA,6CAA6C,qDAAqD;AAClG;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,uDAAuD;AACjG;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2EAA2E,SAAS,yBAAyB,iBAAiB,iBAAiB,SAAS;AACxJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACxSA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD,YAAY,+CAA+C,UAAU,SAAS,QAAQ;AAC9I;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wDAAwD,oBAAoB;AAC5E;;AAEA;AACA;;AAEA;;AAEA,wCAAwC,mDAAmD;AAC3F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,UAAU,qBAAqB,QAAQ;AACnG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,mCAAmC;AACpE;AACA,C;;;;;;;;;;;;ACpMA;AAAA;AAAA;AAAA;AAA2C;AACN;;AAE9B,mBAAmB,uDAAS;AACnC;AACA,IAAI,iDAAM;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,WAAW,iDAAM;AACjB;AACA;AACA;;AAEA;AACA,YAAY,qEAAqE;AACjF;AACA,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,E;;;;;;;;;;;;AC9BnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;;AAED;AACD;AACF;;AAEvB,kHAAO,E;;;;;;;;;;;;ACNtB;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA,2EAA2E;AAC3E;AACA;;AAEA;AACA;AACA,mBAAmB,oDAAoD;AACvE;;AAEA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA,8BAA8B,oCAAoC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACO,4B","file":"GameGUI.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GameGUI\"] = factory();\n\telse\n\t\troot[\"GameGUI\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","export class Component {\r\n  constructor ( option = {}, config = {}, dataFromParent = {} ) {\r\n    // Note: \"option\" and \"config\" are registered at first include when Comp is instantiated.\r\n    //       These props wont be updated even if then change at subsequent re-renderings.\r\n    this.option                     = option;\r\n    this.config                     = config;\r\n\r\n    this.id                         = typeof config.id !== 'undefined' ? config.id : this.uid();\r\n    this.type                       = this.getTypeOfComp( this );\r\n    this.classNameInHtml            = this.camelCaseToSnakeCase( this.type );\r\n    this.dom                        = this.createDomRepresentation();\r\n    // Note: \"this.dom\" this is a wrapper element. The output of \"this.render(..)\"\r\n    // is placed inside this wrapper. The wrapper is created only once at\r\n    // Comp instantiation, but its content is created from scratch, then injected at\r\n    // every Comp Render call - at this.render(..).\r\n    this.listObjCompChildByType     = {}; // Cache previously rendered Comps here.\r\n    this.html                       = null;\r\n    this.ctrChildByType             = {};\r\n\r\n    this.state                      = {};\r\n    this.isStateUpdated             = false; // when Comp State is updated, this is set to true till\r\n                                             // State Change is rendered to HTML/DOM\r\n    this.dataFromParentAsStringPrev = undefined;\r\n  }\r\n\r\n  getTypeOfComp ( comp ) {\r\n    // Issue: Babel transpiles MyCompName to MyCompName_ImportedCompName. We are filtering this off here.\r\n    //        If we ignored this, the code wouldn't be compilable.\r\n    const type = Object.getPrototypeOf(comp).constructor.name;\r\n    const listTypePart = type.split('_');\r\n    return listTypePart[ listTypePart.length -1 ];\r\n  }\r\n\r\n  createDomRepresentation () {\r\n    const domElement = document.createElement('div');\r\n    domElement.classList.add( this.classNameInHtml );\r\n    domElement.setAttribute('id', this.id);\r\n\r\n    return domElement;\r\n  }\r\n\r\n  render() {\r\n    return `<span>Placeholder text for Comp ${this.type}</span>`;\r\n  }\r\n\r\n  /**\r\n   * Syntax: ..${this.include(ClassComp, dataFromParent, config)}\r\n   * Use \"include\" inside any \"render\" method to embed Comps inside Comps.\r\n   * It returns a Placeholder HTML Snippet, that is included in the Parent Comps DOM till\r\n   * the next Game GUI Render Event will call \"renderToHtmlAndDomify\" on Parent Comp,\r\n   * when all Placeholder HTML Snippet will be replaced with the relevant Included Comps DOM.\r\n   * @param ClassComp\r\n   * @param dataFromParent\r\n   * @param config\r\n   * @returns {string|*}\r\n   */\r\n  include ( ClassComp, dataFromParent, config ) {\r\n    // If Smart Comp (Class)\r\n    if ( ClassComp.prototype instanceof Component ) {\r\n      const typeComp = ClassComp.name;\r\n      const ctrChild = this.ctrChildByType[ typeComp ] = typeof this.ctrChildByType[ typeComp ] === 'undefined' ?\r\n        0                                                   :\r\n        ++this.ctrChildByType[ typeComp ];\r\n\r\n      const idCompChild = (config && typeof config.id !== 'undefined') ? config.id : ctrChild;\r\n      this.listObjCompChildByType[ typeComp ] = this.listObjCompChildByType[ typeComp ] || {};\r\n      let compChild = this.listObjCompChildByType[ typeComp ][ idCompChild ];\r\n\r\n      // Create new instance of Comp only if it hasn't been created yet\r\n      if ( typeof compChild === 'undefined' ) {\r\n        compChild = this.listObjCompChildByType[ typeComp ][ idCompChild ] = new ClassComp( this.option, config, dataFromParent );\r\n        // Note: \"option\" is a global in the scope of Game GUI, therefore we pass it along to every Child Comp,\r\n        //       hence making it available in every Comp through \"this.option\".\r\n        //       \"config\" and \"dataFromParent\" on the other hand are specific to each Comp,\r\n        //       therefore we pass in a new one at every include, unlike we do with \"option\".\r\n        //       \"option\" and \"config\" both are registered when the Comp is instantiated (at first inclusion),\r\n        //       then we never update them again, even if we include them multiple times with different config,\r\n        //       that won't effect the original config. Therefore, you are welcome to modify it (e.g. in constructor)\r\n        //       after Comp is instantiated, those modifications will remain.\r\n        //       \"dataFromParent\" on the other hand will be update and passed in to \"render\" method,\r\n        //       every time the Parent Comp is re-rendered.\r\n\r\n        // Hook up Game GUI Methods: scheduler, indexComp\r\n        // Note: make sure you dont bind this, you need scheduler to resolve to ui framework,\r\n        //       and not to Comp instance.\r\n        //       These hooked up methods wont be used/called at construction time,\r\n        //       therefore there is no problem hooking them up after Comp Instantiation.\r\n        compChild.scheduleRendering = this.scheduleRendering;\r\n        compChild.indexComp         = this.indexComp;\r\n        compChild.listBindExternal  = this.listBindExternal;\r\n        compChild.gameGUI           = this.gameGUI;\r\n\r\n        // Index Comp (by \"type\" and \"id\") for quick access, right after its created and even before its rendered.\r\n        // Note: The rendering of Root Comp will trigger the indexing of all Sub Comps.\r\n        this.indexComp( compChild );\r\n\r\n        // Run Life Cycle Method if defined on Comp Instance\r\n        if  (typeof compChild.afterInstantiation !== 'undefined') {\r\n          compChild.afterInstantiation( dataFromParent );\r\n        }\r\n      }\r\n\r\n      compChild.renderToHtmlAndDomify( dataFromParent );\r\n      // Note: \"dataFromParent\" from Parent Comp is updated in Child Comp by \"include\", but\r\n      //       \"config\" and \"option\" are not, they are passed in only at first inclusion (at Comp Instantiation)\r\n\r\n      const idFromConfig = (config && typeof config.id !== 'undefined') ? config.id : '';\r\n\r\n      return `<div class=\"comp-placeholder\" type=\"${typeComp}\" id-from-config=\"${idFromConfig}\" ctr-child=\"${ctrChild}\">placeholder text</div>`;\r\n\r\n      // If Dumb Comp (Function)\r\n    } else {\r\n      return ClassComp( dataFromParent, this.option );\r\n    }\r\n  };\r\n\r\n  renderToHtmlAndDomify ( dataFromParent ) {\r\n    // Optimise Rendering to HTML\r\n    // Note: Comp HTML Representation can change one of three ways:\r\n    //       A) Data Passed in from Parent Comp has changed\r\n    //       B) State has changed\r\n    //       C) HTML Representation of Comp has never been created before, therefore\r\n    //          what ever we render will be different from current HTML Representation of the Comp.\r\n\r\n    const renderBecauseDataPassedInChanged = this.isRenderBecauseDataPassedInChanged ( dataFromParent );\r\n\r\n    // Don't skip if HTML representation of Comp has never been rendered yet.\r\n    // Skip only if Data Passed In From Parent Comp hasn't changed and the sate of the Comp hasn't changed either\r\n    if (this.html !== null &&\r\n      !renderBecauseDataPassedInChanged &&\r\n      !this.isStateUpdated\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    // Note: Record of Data Passed In From Parent has already been updated by \"isRenderBecauseDataPassedInChanged\"\r\n    //       because we have already stringified Data Passed In From Parent in \"isRenderBecauseDataPassedInChanged\",\r\n    //       therefore we don't want to do it twice, efficiency\r\n    // !! this.dataFromParentAsStringPrev = JSON.stringify( dataFromParent );\r\n\r\n    // Render to HTML String\r\n    this.ctrChildByType = {};\r\n    var htmlNewRender   = this.render( dataFromParent );\r\n    this.isStateUpdated = false; // Updated Comp State is rendered to HTML/DOM at \"this.render(..)\", so we reset it here\r\n\r\n    // Skip ReDomify if Comp Shallow Render looks the same\r\n    // Note: if the Data Passed In From Parent has changed and/or Comp State has changed,\r\n    //       that doesn't necessarily mean that the rendered HTML is different\r\n    if ( htmlNewRender === this.html ) {\r\n      return false;\r\n    }\r\n\r\n    this.html = htmlNewRender;\r\n\r\n    // DOMify HTML String\r\n    this.dom.innerHTML = this.html;\r\n\r\n    // Hide Component - DOM Node included, if Component has nothing to render\r\n    if (this.html === '') {\r\n      this.dom.style.visibility = 'hidden';\r\n    } else {\r\n      this.dom.style.visibility = 'visible';\r\n    }\r\n\r\n    // Bind Built in Event Handlers automatically right after DOM is ready\r\n    this.doBindExternal();\r\n\r\n    // Run Life Cycle Method if defined on Comp Instance\r\n    if  (typeof this.afterRender !== 'undefined') {\r\n      this.afterRender();\r\n    }\r\n\r\n    // Inject Child Comps if any\r\n    this.replaceCompPlaceholderAll( this.dom );\r\n\r\n    return true;\r\n  }\r\n\r\n  isRenderBecauseDataPassedInChanged ( dataFromParent ) {\r\n    const isUndefinedDataFromParentAsStringPrev = typeof this.dataFromParentAsStringPrev === 'undefined';\r\n    const isUndefinedDataFromParentAsString     = typeof dataFromParent                  === 'undefined';\r\n\r\n    // Scenario 1)  prev === undefined && passed === undefined --> DON'T RENDER\r\n    if ( isUndefinedDataFromParentAsStringPrev &&\r\n      isUndefinedDataFromParentAsString\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    const dataFromParentAsString = JSON.stringify( dataFromParent );\r\n\r\n    // Scenario 2)  prev === undefined && passed !== undefined --> RENDER\r\n    if ( isUndefinedDataFromParentAsStringPrev &&\r\n      !isUndefinedDataFromParentAsString\r\n    ) {\r\n      this.dataFromParentAsStringPrev = dataFromParentAsString;\r\n      return true;\r\n    }\r\n\r\n    // Scenario 3)  prev !== undefined && passed === undefined --> RENDER\r\n    if ( !isUndefinedDataFromParentAsStringPrev &&\r\n      isUndefinedDataFromParentAsString\r\n    ) {\r\n      this.dataFromParentAsStringPrev = dataFromParentAsString;\r\n      return true;\r\n    }\r\n\r\n    // Scenario 4)  prev !== undefined && passed !== undefined --> COMPARE\r\n    if ( !isUndefinedDataFromParentAsStringPrev &&\r\n      !isUndefinedDataFromParentAsString\r\n    ) {\r\n      // Compare / same       --> DON'T RENDER\r\n      if ( this.dataFromParentAsStringPrev === dataFromParentAsString) {\r\n        return false;\r\n\r\n        // Compare / different  --> RENDER\r\n      } else {\r\n        this.dataFromParentAsStringPrev = dataFromParentAsString;\r\n        return true;\r\n      }\r\n    }\r\n\r\n    console.error('Something unexpected happened o_0?');\r\n  debugger;\r\n  }\r\n\r\n  doBindExternal() {\r\n    // ui-MY-NAME-COMES-HERE | Do link bindings automatically right after rendering\r\n    // Note: Binding happens before Child Comps are injected so Encapsulation is unharmed\r\n    if (this.listBindExternal && 0 < this.listBindExternal.length) {\r\n      for (let indexListBindExternal = 0; indexListBindExternal < this.listBindExternal.length; indexListBindExternal++) {\r\n        const bindExternal = this.listBindExternal[ indexListBindExternal ];\r\n\r\n        const listNodeBtnUiClick = this.dom.querySelectorAll('['+bindExternal.nameAttribute+']');\r\n        for (let indexListNodeBtnUiClick = 0; indexListNodeBtnUiClick < listNodeBtnUiClick.length; indexListNodeBtnUiClick++) {\r\n          const domNode = listNodeBtnUiClick[ indexListNodeBtnUiClick ];\r\n\r\n          const valueAttrib = domNode.getAttribute(bindExternal.nameAttribute);\r\n          domNode.addEventListener(bindExternal.typeEvent, (evt) => {\r\n            bindExternal.callback.call(this, valueAttrib, domNode, evt);\r\n          }, false);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  replaceCompPlaceholderAll () {\r\n    // Get a list of all Placeholder Child Component\r\n    var nodeListPlaceholder = this.dom.querySelectorAll('.comp-placeholder');\r\n\r\n    // Iterate over all Placeholder Child Comps and replace them with Comp DOM\r\n    for (let indexNodeListPlaceholder = 0; indexNodeListPlaceholder < nodeListPlaceholder.length; indexNodeListPlaceholder++) {\r\n      let dPlaceholder = nodeListPlaceholder[ indexNodeListPlaceholder ];\r\n\r\n      const typeComp          = dPlaceholder.getAttribute('type');\r\n      const idCompFromConfig  = dPlaceholder.getAttribute('id-from-config');\r\n      const ctrChild          = dPlaceholder.getAttribute('ctr-child');\r\n\r\n      const idCompChild = !!idCompFromConfig ? idCompFromConfig : ctrChild;\r\n      const compChild   = this.listObjCompChildByType[ typeComp ][ idCompChild ];\r\n\r\n      if (!compChild) {\r\n        const message  = `Warning: Component can't be found: typeComp===\"${typeComp}\", idCompFromConfig===\"${idCompFromConfig}\", ctrChild===\"${ctrChild}\". State of Cached Comps: `;\r\n        console.warn(message, JSON.stringify(this.listObjCompChildByType));\r\n        continue;\r\n      }\r\n\r\n      compChild.dom = dPlaceholder.insertAdjacentElement('beforebegin', compChild.dom);\r\n      dPlaceholder.parentNode.removeChild(dPlaceholder);\r\n    }\r\n  };\r\n\r\n  getState () {\r\n    return this.state;\r\n  };\r\n\r\n  setState ( stateNew ) {\r\n    this.state = stateNew;\r\n    this.isStateUpdated = true;\r\n\r\n    if ( typeof this.scheduleRendering !== 'undefined' ) {\r\n      this.scheduleRendering( this );\r\n    }\r\n  };\r\n\r\n\r\n  // # Utility\r\n  // # #######\r\n\r\n  camelCaseToSnakeCase (str) {\r\n    return str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase()\r\n  }\r\n\r\n  uid () {\r\n    return Date.now()+''+Math.round(Math.random() * 100000);\r\n  }\r\n}","export class GameGUI {\r\n  constructor(RootComp, selectorGuiRoot, option, configRootComp) {\r\n    // Reg Root Comp automatically if requirements are fulfilled\r\n    // Note: don't run it by default, you may want to control the steps.\r\n    if (typeof RootComp === 'undefined' ||\r\n      typeof selectorGuiRoot === 'undefined'\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this.init(option);\r\n    this.regRootComp(RootComp, selectorGuiRoot, configRootComp);\r\n\r\n    // Register Global 'gui-click' Built in Event Handler\r\n    this.registerBindingBuiltIn();\r\n\r\n    // Call the very first render ASAP\r\n    // Note:  Otherwise you might see a brief flash\r\n    //        Running render in the constructor means, all includes will be called recursively,\r\n    //        therefore all Comp / SubC omp Instantiation will happen sequentially when Game GUI is Instantiated.\r\n    //        That said, all Comps are indexed and ready to be accessed right after Game GUI Instantiation.\r\n    setTimeout(this.render.bind(this), 0);\r\n  };\r\n\r\n  init(option = {}) {\r\n    this.optionDefault = {\r\n      fps: 60,\r\n    };\r\n\r\n    // Should compose option from default options, and options passed in at construction\r\n    this.option = {\r\n      ...this.optionDefault,\r\n      ...option,\r\n    };\r\n\r\n    this.isRenderingDue = false;\r\n    this.listObjIdRenderingScheduled = {};\r\n\r\n    // Indexed list of all rendered Comps\r\n    this.listObjTypeComp  = {};\r\n    this.listObjIdComp    = {};\r\n\r\n    // Store and call from the list of callbacks passed in to be run right after rendering(s) is complete.\r\n    this.listBindExternal = [];\r\n    this.listObjTypeListEventListener = {};\r\n    this.isDOMContentReady = false;\r\n\r\n    // Note: Don't worry about calling render 60 times a sec,\r\n    // render method start with \"if(!this.isRenderingDue ) return;\"\r\n    this.tokenUiRender;\r\n    if (typeof interval !== 'undefined') {\r\n      this.tokenUiRender = interval.setInterval(this.render.bind(this), Math.floor(1000/this.option.fps));\r\n    } else {\r\n      this.tokenUiRender = setInterval(this.render.bind(this), Math.floor(1000/this.option.fps));\r\n    }\r\n  }\r\n\r\n  regRootComp ( RootComp, selectorGuiRoot, configRootComp ) {\r\n    // Get UI Root\r\n    this.domRoot = document.querySelector( selectorGuiRoot );\r\n\r\n    // Throws if Root DOM Element doesn't exist\r\n    if (this.domRoot === null) {\r\n      throw('ERROR: DOM Root can\\'t be found by using the provided selector: ' + selectorGuiRoot);\r\n    }\r\n\r\n    // Instantiate Root Comp\r\n    this.rootComp = new RootComp( this.option, configRootComp );\r\n\r\n    // Hook up Game GUI Methods: scheduler, indexComp, ..\r\n    // Note: we dont want to pass in scheduler into comps, we want to keep comp constructor clean,\r\n    //       therefore we do it here manually for Root Comp, and child comps are managed the same way.\r\n    this.rootComp.scheduleRendering = this.scheduleRendering.bind( this );\r\n    this.rootComp.indexComp         = this.indexComp.bind( this );\r\n    this.rootComp.listBindExternal  = this.listBindExternal;\r\n    this.rootComp.gameGUI           = this;\r\n\r\n    // Run Life Cycle Method if defined on Root Comp Instance\r\n    if  (typeof this.rootComp.afterInstantiation !== 'undefined') {\r\n      this.rootComp.afterInstantiation();\r\n    }\r\n\r\n    // Index Root Comp\r\n    // Root Comp is an Instance of Component, therefore it is indexed the same way as every other Comp Inst.\r\n    this.indexComp( this.rootComp );\r\n\r\n    // Schedule render the very first time\r\n    this.rootComp.scheduleRendering( this.rootComp );\r\n\r\n    // Inject Root Comp into DOM\r\n    this.domRoot.insertAdjacentElement( 'afterbegin', this.rootComp.dom );\r\n  };\r\n\r\n  registerBindingBuiltIn() {\r\n    // Register Global 'gui-click' Built in Event Handler\r\n    this.registerBinding('gui-click', 'click', function (nameHandler, domNode, evt) {\r\n      if (typeof this[nameHandler] === 'undefined') {\r\n        console.warn(`Game GUI: click handler called \"${nameHandler}\" can't be found on the Component (type === '${this.type}', id: ${this.id}).`);\r\n        return;\r\n      }\r\n\r\n      this[nameHandler].call(this, domNode, 'click', evt);\r\n    });\r\n  }\r\n\r\n  scheduleRendering (comp) {\r\n    if ( !comp || !comp.id ) {\r\n      throw('Non-standard Comp passed in to be scheduled. Comp is either undefined or Comp ID is undefined or null or Empty string etc..');\r\n    }\r\n\r\n    this.isRenderingDue = true;\r\n    this.listObjIdRenderingScheduled[ comp.id ] = comp;\r\n  };\r\n\r\n  render () {\r\n    // Skipp rendering if there was no change\r\n    if (!this.isRenderingDue) {\r\n      return false;\r\n    }\r\n\r\n    // Render any Comp. that is scheduled\r\n    for (let idComp in this.listObjIdRenderingScheduled) {\r\n      let comp = this.listObjIdRenderingScheduled[ idComp ];\r\n\r\n      // Recover stored data passed in from Parent Comp previously, and pass it along to Comp Rendering.\r\n      let dataFromParentPrev = typeof comp.dataFromParentAsStringPrev !== 'undefined' ?\r\n        JSON.parse( comp.dataFromParentAsStringPrev ) :\r\n        undefined;\r\n\r\n      comp.renderToHtmlAndDomify( dataFromParentPrev );\r\n      delete this.listObjIdRenderingScheduled[ idComp ];\r\n    }\r\n\r\n    this.isRenderingDue = false;\r\n\r\n    // Fire Event Listeners (if any)\r\n    if( !this.isDOMContentReady ) {\r\n      this.isDOMContentReady = true;\r\n      this.fireEventListener('DOMContentLoaded');\r\n    }\r\n    this.fireEventListener('rendered');\r\n\r\n    return true;\r\n  };\r\n\r\n  addEventListener( typeEvent, callback ) {\r\n    this.listObjTypeListEventListener[typeEvent] = this.listObjTypeListEventListener[typeEvent] || [];\r\n    this.listObjTypeListEventListener[typeEvent].push( {typeEvent, callback} );\r\n  }\r\n\r\n  fireEventListener( typeEvent ) {\r\n    const listEventListener = this.listObjTypeListEventListener[ typeEvent ];\r\n\r\n    if (typeof listEventListener === 'undefined') return;\r\n\r\n    for (let indexListEventListener = 0; indexListEventListener < listEventListener.length; indexListEventListener++) {\r\n      const eventListener = listEventListener[ indexListEventListener ];\r\n      eventListener.callback( eventListener.typeEvent );\r\n    }\r\n  }\r\n\r\n  indexComp( comp ) {\r\n    // Index Comps by Type\r\n    this.listObjTypeComp[ comp.type ] = this.listObjTypeComp[ comp.type ] || [];\r\n    this.listObjTypeComp[ comp.type ].push( comp );\r\n\r\n    // Check for Duplicate Comp ID\r\n    if (this.listObjIdComp[ comp.id ]) {\r\n      throw `Duplicate Comp ID is not allowed. Comp Type \"${comp.type}\", ID in question: ${comp.id}`;\r\n    }\r\n\r\n    // Index Comps by ID\r\n    this.listObjIdComp[ comp.id ] = comp;\r\n  };\r\n\r\n  getCompByType ( type ) {\r\n    // todo: feel free to remove remove after 20200101\r\n    console.warn('Deprecated: \"getCompByType( type )\". Use \"getListCompByType( type )\" instead. \"getCompByType( type )\" will not be supported after end of 2019.');\r\n    return this.listObjTypeComp[ type ];\r\n  }\r\n\r\n  getListCompByType ( type ) {\r\n    return this.listObjTypeComp[ type ];\r\n  }\r\n\r\n  getCompById ( id ) {\r\n    return this.listObjIdComp[ id ];\r\n  }\r\n\r\n  getDomRoot() {\r\n    return this.domRoot;\r\n  }\r\n\r\n  registerBinding(nameAttribute, typeEvent, callback ) {\r\n    this.listBindExternal.push( {nameAttribute, typeEvent, callback} );\r\n  }\r\n}","import { Component } from \"./Component.js\";\r\nimport { router } from './router.js';\r\n\r\nexport class Rout extends Component {\r\n  afterInstantiation ( path ) {\r\n    router.subToHashChange( path, pathListSub => {\r\n      this.setState({\r\n        idChange: this.uid(),\r\n      });\r\n    });\r\n  }\r\n\r\n  render( path ) {\r\n    // Return the Comp that matches the Path provided - Partial Match to the Left works.\r\n    return router.runIfPathMatch( path, dataInHash =>\r\n      /*\r\n        Note: \"this.config\" is the \"CompToRenderWhenPathTriggered\".\r\n              This is counter intuitive but simplifies the API of a Rout.\r\n\r\n        When we include a new Rout\r\n        ..${this.include(GameGUI.Rout, 'my/path', CompToRenderWhenPathTriggered)}..\r\n        You can see that \"CompToRenderWhenPathTriggered\" becomes \"this.config\".\r\n        ..${this.include(ClassComp, dataFromParent, config)}..\r\n        ClassComp: GameGUI.Rout, dataFromParent: 'my/path', config: CompToRenderWhenPathTriggered\r\n      */\r\n      (this.include(this.config, dataInHash))\r\n    );\r\n  }\r\n}\r\n\r\nexport default Rout;","import { GameGUI }    from './GameGUI.js';\r\n\r\nexport { Component }  from './Component';\r\nexport { router }     from './router.js'\r\nexport { Rout }       from './Rout.js'\r\n\r\nexport default GameGUI;","export class Router {\r\n  constructor() {\r\n    this.listObjRoutParsedCurrent = {};\r\n    this.listSub                  = [];\r\n    this.listObjPathListSub       = {}; // note: this is for debugging only\r\n\r\n    window.addEventListener(\"hashchange\", this.handlerHashChange.bind( this ), false);\r\n    this.handlerHashChange();\r\n  }\r\n\r\n  init( gui ) {\r\n    gui.registerBinding('gui-href', 'click', url => {\r\n      this.updateHash( url );\r\n    });\r\n  }\r\n\r\n  getHash( hashInput ) {\r\n    // Filter off \"#\"\r\n    // Note: no str.replace(..) cos its slow\r\n    const hashUpdate = hashInput || location.hash;\r\n    const hashRawParts = hashUpdate.split('#');\r\n\r\n    if ( 2 < hashRawParts.length ) {\r\n      throw 'Only one \"#\" is allowed in the URL.';\r\n    }\r\n\r\n    return hashRawParts.join('');\r\n  }\r\n\r\n  getListRout( hashInput ) {\r\n    const hash = this.getHash( hashInput );\r\n\r\n    // Single Rout in hash\r\n    if (hash.indexOf('|') === -1 ) {\r\n      return [hash];\r\n\r\n      // Multiple Routs in hash\r\n    } else {\r\n      return hash.split('|')\r\n        .filter( rout => rout !== '');\r\n    }\r\n  }\r\n\r\n  processRout( rout ) {\r\n    const routProcessed = {\r\n      id:               null,\r\n      listObjAttribute: {},\r\n      path:             null\r\n    };\r\n\r\n    let routRemaining;\r\n    // Find \"id\" in Rout if any. Not having \"id\" is valid syntax\r\n    // E.g: \"gui:menu/main\" => id === 'gui', or \"menu/main\" => id === undefined.\r\n    // Note: \"#\" is already removed from Rout\r\n    if ( rout.indexOf(':') !== -1 ) {\r\n      const routListPartById = rout.split(':');\r\n      routProcessed.id = routListPartById[ 0 ];\r\n      routRemaining = routListPartById[ 1 ];\r\n    } else {\r\n      routProcessed.id = 'noId';\r\n      routRemaining = rout;\r\n    }\r\n\r\n    // If at least one Attribute provided in Rout\r\n    if ( routRemaining.indexOf('?') !== -1 ) {\r\n      const listPartByQuestionmark = routRemaining.split('?');\r\n      routProcessed.path      = listPartByQuestionmark[0];\r\n      const strListAttribute  = listPartByQuestionmark[1];\r\n      const listAttributeStr  = strListAttribute.split('&');\r\n\r\n      // Turn Attribute String into Attribute Key Value Pair.\r\n      // E.g. \"user=Jane\" => listObjAttribute['user'] = 'Jane';\r\n      // E.g. \"foo\"       => listObjAttribute['foo']  = true;\r\n      listAttributeStr.forEach(attributeStr => {\r\n        if ( attributeStr.indexOf('=') !== -1 ) {\r\n          const listPartByEqualSign = attributeStr.split('=');\r\n          routProcessed.listObjAttribute[ listPartByEqualSign[0] ] = listPartByEqualSign[1];\r\n        } else {\r\n          routProcessed.listObjAttribute[ attributeStr ] = true;\r\n        }\r\n      });\r\n\r\n      // If NO Attribute is provided in Rout\r\n    } else {\r\n      routProcessed.path = routRemaining;\r\n    }\r\n\r\n    return routProcessed;\r\n  }\r\n\r\n  handlerHashChange () {\r\n    const listRoutStr = this.getListRout();\r\n    const listObjRoutParsedCurrentUpdate = {};\r\n    listRoutStr.forEach( routStr => {\r\n      const routObj = this.processRout( routStr );\r\n      listObjRoutParsedCurrentUpdate[ routObj.id ] = routObj;\r\n    });\r\n\r\n    this.listObjRoutParsedCurrent = listObjRoutParsedCurrentUpdate;\r\n\r\n    this.fireAllSub();\r\n  }\r\n\r\n  subToHashChange ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ) {\r\n    this.listSub.push( fnToCallIfMatch );\r\n    this.subToPath ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ); // note: this is for debugging only\r\n    this.handlerHashChange();\r\n  }\r\n\r\n  subToPath ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ) {\r\n    const listSub = this.listObjPathListSub[ pathToMatch ] = this.listObjPathListSub[ pathToMatch ] || [];\r\n    listSub.push( {pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch} );\r\n  }\r\n\r\n  runIfPathMatch ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch, singleActivation ) {\r\n    let routParsedCurrentMatching;\r\n\r\n    // Filter off Path ID from \"pathToMatch\"\r\n    // E.g. \"somePathId:my/path\" -> pathToMatch = \"my/path\"; idToMatch = 'somePathId'\r\n    let listPartPath = pathToMatch.split(':');\r\n    let idToMatch = 1 < listPartPath.length ? listPartPath[0] : 'noId';\r\n    pathToMatch   = 1 < listPartPath.length ? listPartPath[1] : listPartPath[0];\r\n\r\n    // Search\r\n    // Iterate List of Current Routs/Paths\r\n    for ( let idListRout in this.listObjRoutParsedCurrent) {\r\n      const routParsedCurrent = this.listObjRoutParsedCurrent[ idListRout ];\r\n\r\n      // If Current Routs/Paths Iter matching Path that we are searching for\r\n      if (routParsedCurrent.id === idToMatch &&\r\n        // Note: Partial Matching to Left: Match it only to the left, e.g.: main/setting & main/setting/audio\r\n        routParsedCurrent.path.indexOf(pathToMatch) === 0\r\n      ) {\r\n        routParsedCurrentMatching = routParsedCurrent;\r\n      }\r\n    }\r\n\r\n    // Matching\r\n    // If there is a matching Subscriber/Rout\r\n    if ( routParsedCurrentMatching ) {\r\n      // If \"fnToCallIfMatch\" should be called once in subsequent matching Paths\r\n      if ( singleActivation ) {\r\n        // If Path was inactive up to now\r\n        if ( !fnToCallIfMatch.isActive ) {\r\n          fnToCallIfMatch.isActive = true;\r\n          fnToCallIfMatch.listObjAttribute = routParsedCurrentMatching.listObjAttribute;\r\n          return fnToCallIfMatch( routParsedCurrentMatching.listObjAttribute );\r\n\r\n          // If Path was inactivated by prev path\r\n        } else {\r\n          return '';\r\n        }\r\n\r\n      } else {\r\n        return fnToCallIfMatch( routParsedCurrentMatching.listObjAttribute );\r\n      }\r\n\r\n      // NOT Matching\r\n      // If there is NO matching Subscriber/Rout, and we have a Callback to call when doesnt match\r\n    } else if ( typeof fnToCallIfDoesntMatch !== 'undefined' ) {\r\n      // If Rout was active with prev Path\r\n      // Note: it makes sure that \"fnToCallIfDoesntMatch\" is called only once\r\n      if (fnToCallIfMatch.isActive) {\r\n        fnToCallIfMatch.isActive = false;\r\n        fnToCallIfDoesntMatch( fnToCallIfMatch.listObjAttribute );\r\n        fnToCallIfMatch.listObjAttribute = null;\r\n      }\r\n\r\n      return '';\r\n\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  fireAllSub () {\r\n    for (let indexListSub = 0; indexListSub < this.listSub.length; indexListSub++) {\r\n      const sub = this.listSub[ indexListSub ];\r\n      sub();\r\n    }\r\n  }\r\n\r\n  rout ( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch ) {\r\n    this.subToHashChange( pathToMatch, () => {\r\n      this.runIfPathMatch( pathToMatch, fnToCallIfMatch, fnToCallIfDoesntMatch, true );\r\n    }, fnToCallIfDoesntMatch );\r\n  }\r\n\r\n  updateHash ( hashNew ) {\r\n    // Collect List of Routs as List of Strings rep. Routs\r\n    const listRoutStr = this.getListRout( hashNew );\r\n\r\n    // Process List of Routs as String to Obj\r\n    const listObjRoutParsedNew = {};\r\n    listRoutStr.forEach( routStr => {\r\n      const routObj = this.processRout( routStr );\r\n      listObjRoutParsedNew[ routObj.id ] = routObj;\r\n    });\r\n\r\n    // Update List of Hash on record\r\n    const listObjRoutParsedUpdate = {\r\n      ...this.listObjRoutParsedCurrent,\r\n      ...listObjRoutParsedNew\r\n    };\r\n\r\n    const hashUpdated = this.reconstructHash( listObjRoutParsedUpdate );\r\n    location.hash = hashUpdated;\r\n  }\r\n\r\n  reconstructHash( listObjByIdRoutObj ) {\r\n    let hashReconstructed = '';\r\n\r\n    // Multiple Rout Objects\r\n    if ( 1 < Object.keys(listObjByIdRoutObj).length ) {\r\n      let ctrRout = 0;\r\n\r\n      // Iterate over the List of Rout Objects\r\n      for (let idRoutObj in listObjByIdRoutObj) {\r\n        const routObjIter = listObjByIdRoutObj[ idRoutObj ];\r\n\r\n        // Add Rout Divider \"|\" if there are multiple Routs\r\n        if (ctrRout) hashReconstructed += '|';\r\n\r\n        // Reconstruct first part, ID + Path\r\n        hashReconstructed += routObjIter.id + ':' + routObjIter.path;\r\n\r\n        // Reconstruct Attributes from Rout Iter to Hash format, if any\r\n        hashReconstructed = this.reconstructHashAttributeAll( hashReconstructed, routObjIter );\r\n\r\n        ctrRout++;\r\n      }\r\n\r\n      // Single Rout on record\r\n    } else {\r\n      const idRoutObj = Object.keys( listObjByIdRoutObj )[ 0 ];\r\n      const routObj = listObjByIdRoutObj[ idRoutObj ];\r\n\r\n      // Reconstruct first part, ID + Path\r\n      hashReconstructed += routObj.id + ':' + routObj.path;\r\n\r\n      // Reconstruct Attributes from Rout to Hash format, if any. E.g.: ..bar=2&foo&..\r\n      hashReconstructed = this.reconstructHashAttributeAll( hashReconstructed, routObj );\r\n    }\r\n\r\n    return hashReconstructed;\r\n  }\r\n\r\n  reconstructHashAttributeAll( hashReconstructed, routObj ) {\r\n    // If Rout Iter contains Attributes\r\n    if ( 0 < Object.keys(routObj.listObjAttribute).length ) {\r\n      hashReconstructed += '?';\r\n      let ctrAttribute = 0;\r\n\r\n      // Iterate over Rout Attributes\r\n      Object.keys( routObj.listObjAttribute ).forEach( attributeKey => {\r\n        const attributeValue = routObj.listObjAttribute[ attributeKey ];\r\n\r\n        // Add Attribute Divider \"&\" if there are multiple Attributes\r\n        if ( 0 < ctrAttribute ) hashReconstructed += '&';\r\n\r\n        // If Boolean Attribute, e.g.: ..bar=2&foo&.. => foo === true\r\n        if ( typeof attributeValue === 'boolean' ) {\r\n          hashReconstructed += attributeKey;\r\n\r\n          // Any type of Attribute but Boolean\r\n        } else {\r\n          hashReconstructed += attributeKey + '=' + routObj.listObjAttribute[ attributeKey ];\r\n        }\r\n\r\n        ctrAttribute++;\r\n      });\r\n    }\r\n\r\n    return hashReconstructed;\r\n  }\r\n}\r\n\r\n// Export a Single Router Instance, because we only want one Router that is aware of all the Routs\r\nexport const router = new Router();"],"sourceRoot":""}