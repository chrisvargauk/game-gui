{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./src/Component.js","webpack://[name]/./src/GameGUI.js","webpack://[name]/./src/GameGUIRouter.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAO;AACP,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oDAAoD,SAAS,eAAe,cAAc;;AAE1F;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,uCAAuC;AACzE;;AAEA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,wEAAS,E;;;;;;;;;;;;AC5NxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kCAAkC,4DAA4D;AAC9F;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,UAAU,qBAAqB,QAAQ;AACnG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAE4B;AACI;AACjB,sEAAO,E;;;;;;;;;;;;AC/ItB;AAAA;AAAA;AACA;;AAEA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,oCAAoC;AAClE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM,E","file":"GameGUI.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GameGUI\"] = factory();\n\telse\n\t\troot[\"GameGUI\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/GameGUI.js\");\n","export class Component {\n  constructor ( option, config = {}) {\n    this.option                     = option;\n    this.config                     = config;\n    this.id                         = typeof config.id !== 'undefined' ? config.id : this.uid();\n    this.type                       = this.getTypeOfComp(this);\n    this.dom                        = this.createDomElement ( this.type, this.id );\n    this.listObjCompChild           = {};\n    this.html                       = '';\n    this.ctrChild                   = -1;\n    this.state                      = {};\n    this.isStateUpdated             = false;\n    this.dataFromParentAsStringPrev = undefined;\n  }\n\n  createDomElement ( type, id ) {\n    const domElement = document.createElement('div');\n    domElement.classList.add( this.camelCaseToNakeCase( type ) );\n    domElement.setAttribute('id', id);\n\n    return domElement;\n  }\n\n  renderToHtmlAndDomify ( dataFromParent ) {\n    // Skip if Data Passed in from Parent Comp. is the same\n    // or if State has changed\n    if ( this.html !== '' ) {\n      const renderBecauseDataPassedInChanged = this.isRenderBecauseDataPassedInChanged ( dataFromParent );\n      if ( !renderBecauseDataPassedInChanged &&\n        !this.isStateUpdated\n      ) {\n        return false;\n      }\n    } else if (typeof dataFromParent !== 'undefined') {\n      this.dataFromParentAsStringPrev = JSON.stringify( dataFromParent );\n    }\n\n    // Render to HTML String\n    this.ctrChild       = -1;\n    var htmlNewRender   = this.render( dataFromParent );\n    this.isStateUpdated = false;\n    this.ctrChild       = -1;\n\n    // Skip ReDomify if Comp Shallow Render looks the same\n    if ( htmlNewRender === this.html) {\n      return false;\n    }\n\n    this.html = htmlNewRender;\n\n    // DOMify HTML String\n    this.dom.innerHTML = this.html;\n\n    // Do predefined bindings automatically right after DOM is ready\n    this.doBind();\n\n    // Run Life Cycle Method if defined on Comp Instance\n    if  (typeof this.afterRender !== 'undefined') {\n      this.afterRender();\n    }\n\n    // Inject Child Comps if any\n    this.replacePlaceholderAll( this.dom );\n\n    return true;\n  }\n\n  isRenderBecauseDataPassedInChanged ( dataFromParent ) {\n    // Scenario 1)  prev === undefined && passed === undefined --> DON'T RENDER\n    if ( typeof this.dataFromParentAsStringPrev === 'undefined' &&\n      typeof dataFromParent                  === 'undefined'\n    ) {\n      return false;\n    }\n\n    // Scenario 2)  prev !== undefined && passed === undefined --> RENDER\n    if ( typeof this.dataFromParentAsStringPrev !== 'undefined' &&\n      typeof dataFromParent                  === 'undefined'\n    ) {\n      this.dataFromParentAsStringPrev = dataFromParent;\n      return true;\n    }\n\n    // Scenario 3)  prev === undefined && passed !== undefined --> COMPARE\n    if ( typeof this.dataFromParentAsStringPrev === 'undefined' &&\n      typeof dataFromParent                  !== 'undefined'\n    ) {\n      const dataFromParentAsString = JSON.stringify( dataFromParent );\n\n      // Compare / same       --> DON'T RENDER\n      if ( this.dataFromParentAsStringPrev === dataFromParentAsString) {\n        return false;\n\n        // Compare / different  --> RENDER\n      } else {\n        this.dataFromParentAsStringPrev = dataFromParentAsString;\n        return true;\n      }\n    }\n\n    // Scenario 4)  prev !== undefined && passed !== undefined --> COMPARE\n    if ( typeof this.dataFromParentAsStringPrev !== 'undefined' &&\n         typeof dataFromParent                  !== 'undefined'\n    ) {\n      const dataFromParentAsString = JSON.stringify( dataFromParent );\n\n      // Compare / same       --> DON'T RENDER\n      if ( this.dataFromParentAsStringPrev === dataFromParentAsString) {\n        return false;\n\n        // Compare / different  --> RENDER\n      } else {\n        this.dataFromParentAsStringPrev = dataFromParentAsString;\n        return true;\n      }\n    }\n\n    console.error('Something unexpected happened o_0?');\n    debugger;\n  }\n\n  replacePlaceholderAll () {\n    // Get a list of all Placeholder Child Component\n    var nodeListPlaceholder = this.dom.querySelectorAll('.comp-placeholder');\n\n    // Iterate over all Placeholder Child Comps and replace them with Comp DOM\n    for (var indexNodeListPlaceholder = 0; indexNodeListPlaceholder < nodeListPlaceholder.length; indexNodeListPlaceholder++) {\n      var dPlaceholder = nodeListPlaceholder[ indexNodeListPlaceholder ];\n      var compChild = this.listObjCompChild[indexNodeListPlaceholder];\n      compChild.dom = dPlaceholder.insertAdjacentElement('beforebegin', compChild.dom);\n      dPlaceholder.parentNode.removeChild(dPlaceholder);\n    }\n  };\n\n  include ( ClassComp, dataFromParent, config ) {\n    // If Smart Comp (Class)\n    if ( ClassComp.prototype instanceof Component ) {\n      this.ctrChild++;\n      var nameComp  = ClassComp.name;\n      var compChild = this.listObjCompChild[ this.ctrChild ];\n\n      // Create new instance of Comp only if it hasn't been created yet\n      if ( typeof compChild === 'undefined' ) {\n        compChild = this.listObjCompChild[ this.ctrChild ] = new ClassComp( this.option, config );\n        compChild.dataFromParent = dataFromParent;\n\n        // Hook up Game GUI Methods: scheduler, indexComp\n        // Note: make sure you dont bind this, you need scheduler to resolve to ui framework,\n        //       and not to comp instance.\n        //       These hooked up methods wont be called at constructon time,\n        //       therefore there is no problem hooking them up after Comp Instantiation.\n        compChild.scheduleRendering = this.scheduleRendering;\n        compChild.indexComp         = this.indexComp;\n\n        // Index Comp right after its created and even before its rendered.\n        // Note: The rendering of Root Comp will trigger the indexing of all Sub Comps.\n        this.indexComp( compChild );\n      }\n\n      compChild.renderToHtmlAndDomify( compChild.dataFromParent );\n\n      return `<div class=\"comp-placeholder\" type=\"${nameComp}\" ctr-child=\"${this.ctrChild}\"></div>`;\n\n    // If Dumb Comp (Function)\n    } else {\n      return ClassComp( dataFromParent, this.option );\n    }\n  };\n\n  doBind () {\n    // ui-click | Do click handler bindings automatically right after rendering\n    // Note: Binding happens before Child Comps are injected so Encapsulation is unharmed\n    const listNodeBtn = this.dom.querySelectorAll('[ui-click]');\n    for (let indexListNodeBtn = 0; indexListNodeBtn < listNodeBtn.length; indexListNodeBtn++) {\n      const nodeBtn = listNodeBtn[ indexListNodeBtn ];\n\n      const handler = nodeBtn.getAttribute('ui-click');\n      if (typeof this[handler] === 'undefined') {\n        console.warn(`UI: click handler called \"${handler}\" can't be found on the Component.`);\n        continue;\n      }\n\n      nodeBtn.addEventListener('click', this[handler].bind(this), false);\n    }\n  }\n\n  getState () {\n    return this.state;\n  };\n\n  setState ( stateNew ) {\n    this.state = stateNew;\n    this.isStateUpdated = true;\n\n    if ( typeof this.scheduleRendering !== 'undefined' ) {\n      this.scheduleRendering( this );\n    }\n  };\n\n\n  // # Utility\n  // # #######\n\n  camelCaseToNakeCase (str) {\n    return str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase()\n  }\n\n  uid () {\n    return Date.now()+''+Math.round(Math.random() * 100000);\n  }\n\n  getTypeOfComp ( comp ) {\n    // Issue: Babel transpiles MyCompName to MyCompName_ImportedCompName. We are filtering this off here.\n    //        If we ignored this, the code wouldn't be compilable.\n    const type = Object.getPrototypeOf(comp).constructor.name;\n    const listTypePart = type.split('_');\n    return listTypePart[ listTypePart.length -1 ];\n  }\n}\n\nexport default Component;","export class GameGUI {\n  constructor(RootComp, selectorGuiRoot, option) {\n    // Reg Root Comp automatically if requirements are fulfilled\n    // Note: don't run it by default, you may want to control the steps.\n    if (typeof RootComp === 'undefined' ||\n        typeof selectorGuiRoot === 'undefined'\n    ) {\n      return;\n    }\n\n    this.init(option);\n    this.regRootComp(RootComp, selectorGuiRoot);\n\n    // Call the very first render ASAP\n    // Note:  Otherwise you might see a brief flash\n    //        Running render in the constructor means, all includes will be called recursively,\n    //        therefore all Comp / SubC omp Instantiation will happen sequentially when Game GUI is Instantiated.\n    //        That said, all Comps are indexed and ready to be accessed right after Game GUI Instantiation.\n    this.render();\n  };\n\n  init(option = {}) {\n    this.optionDefault = {\n      fps: 60,\n    };\n\n    this.option = {\n      ...this.optionDefault,\n      ...option,\n    };\n\n    this.isRenderingDue = false;\n    this.listObjIdRenderingScheduled = {};\n\n    // Indexed list of all rendered Comps\n    this.listObjTypeComp = {};\n    this.listObjIdComp = {};\n\n    this.listObjCallback = {\n      listOnRender: [],\n    };\n\n    // Note: Don't worry about calling render 60 times a sec,\n    // render method start with \"if(!this.isRenderingDue ) return;\"\n    this.tokenUiRender;\n    if (typeof interval !== 'undefined') {\n      this.tokenUiRender = interval.setInterval(this.render.bind(this), Math.floor(1000/this.option.fps));\n    } else {\n      this.tokenUiRender = setInterval(this.render.bind(this), Math.floor(1000/this.option.fps));\n    }\n  }\n\n  regRootComp (RootComp, selectorGuiRoot) {\n    // Get UI Root\n    this.domRoot = document.querySelector(selectorGuiRoot);\n\n    // Skip if root DOM Element doesn't exist\n    if (this.domRoot === null) {\n      throw('ERROR: DOM Root can\\'t be found by using the provided selector: ' + selectorGuiRoot);\n    }\n\n    // Instantiate Root Comp\n    this.rootComp = new RootComp( this.option );\n\n    // Hook up Game GUI Methods: scheduler, indexComp\n    // Note: we dont want to pass in scheduler into comps, we want to keep comp constructor clean,\n    //       therefore we do it here manually for Root Comp, and child comps are managed the same way.\n    this.rootComp.scheduleRendering = this.scheduleRendering.bind( this );\n    this.rootComp.indexComp         = this.indexComp.bind( this );\n\n    // Index Root Comp\n    // Root Comp is an Instance of Component, therefore it is indexed the same way as every other Comp Inst.\n    this.indexComp( this.rootComp );\n\n    // Schedule render the very first time\n    this.rootComp.scheduleRendering( this.rootComp );\n\n    // Inject Root Comp into DOM\n    this.domRoot.insertAdjacentElement( 'afterbegin', this.rootComp.dom );\n  };\n\n  scheduleRendering (comp) {\n    this.isRenderingDue = true;\n    this.listObjIdRenderingScheduled[comp.id] = comp;\n  };\n\n  render () {\n    // Skipp rendering if there was no change\n    if (!this.isRenderingDue) {\n      return;\n    }\n\n    // Render any Comp. that is scheduled\n    for (let idComp in this.listObjIdRenderingScheduled) {\n      let comp = this.listObjIdRenderingScheduled[ idComp ];\n\n      let dataFromParentPrev = typeof comp.dataFromParentAsStringPrev !== 'undefined' ?\n        JSON.parse( comp.dataFromParentAsStringPrev ) :\n        undefined;\n\n      comp.renderToHtmlAndDomify( dataFromParentPrev );\n      delete this.listObjIdRenderingScheduled[ idComp ];\n    }\n\n    this.isRenderingDue = false;\n\n    // Call all the render event handlers passed in externally\n    if( 0 < this.listObjCallback.listOnRender.length ) {\n      for(let indexListOnRender=0; indexListOnRender<this.listObjCallback.listOnRender.length; indexListOnRender++) {\n        this.listObjCallback.listOnRender[ indexListOnRender ]();\n      }\n    }\n  };\n\n  onRender ( callback ) {\n    this.listObjCallback.listOnRender.push( callback );\n  }\n\n  indexComp( comp ) {\n    // Index Comps by Type\n    this.listObjTypeComp[ comp.type ] = this.listObjTypeComp[ comp.type ] || [];\n    this.listObjTypeComp[ comp.type ].push( comp );\n\n    // Check for Duplicate Comp ID\n    if (this.listObjIdComp[ comp.id ]) {\n      throw `Duplicate Comp ID is not allowed. Comp Type \"${comp.type}\", ID in question: ${comp.id}`;\n    }\n\n    // Index Comps by ID\n    this.listObjIdComp[ comp.id ] = comp;\n  };\n\n  getCompByType ( type ) {\n    return this.listObjTypeComp[ type ];\n  }\n\n  getCompById ( id ) {\n    return this.listObjIdComp[ id ];\n  }\n}\n\nexport * from './Component';\nexport * from './GameGUIRouter';\nexport default GameGUI;","// http://localhost:8000/demo/demo-11-router.html#@menu:main/setting@game:running?user=Jane&age=20&foo\n// http://localhost:8000/demo/demo-11-router.html#running?user=Jane&age=20&foo\n\n// todo: rerender Comps at hash change\n\nexport class Router {\n  constructor() {\n    this.listRout = [];\n    this.listObjPathToMatch = {};\n    window.addEventListener(\"hashchange\", this.handlerHashChange.bind( this ), false);\n    this.handlerHashChange();\n  }\n\n  getHash() {\n    // Filter off \"#\"\n    // Note: no str.replace(..) cos its slow\n    const hashRawParts = location.hash.split('#');\n\n    if ( 2 < hashRawParts.length ) {\n      throw 'Only one \"#\" is allowed in the URL.';\n    }\n\n    return hashRawParts.join('');\n  }\n\n  getListRout() {\n    const hash = this.getHash();\n\n    // Skip if non-standard Rout is presented\n    if (hash.indexOf('@') === -1 ) {\n      return [hash];\n    }\n\n    const listRout = hash.split('@').filter( rout => rout !== '');\n\n    return listRout;\n  }\n\n  processRout( rout ) {\n    let id,\n        routRemaining;\n    if ( rout.indexOf(':') !== -1 ) {\n      const routListPartById = rout.split(':');\n      id = routListPartById[ 0 ];\n      routRemaining = routListPartById[ 1 ];\n    } else {\n      routRemaining = rout;\n    }\n\n    let listObjAttribute,\n        path;\n    if ( routRemaining.indexOf('?') !== -1 ) {\n      const listPartByQuestionmark = routRemaining.split('?');\n      const strListAttribute  = listPartByQuestionmark[1];\n      const listAttributeStr  = strListAttribute.split('&');\n      path                    = listPartByQuestionmark[0];\n\n      listObjAttribute = {};\n      listAttributeStr.forEach(attributeStr => {\n        if ( attributeStr.indexOf('=') !== -1 ) {\n          const listPartByEqualSign = attributeStr.split('=');\n          listObjAttribute[ listPartByEqualSign[0] ] = listPartByEqualSign[1];\n        } else {\n          listObjAttribute[attributeStr] = true;\n        }\n      });\n\n    } else {\n      path = routRemaining;\n    }\n\n    return {\n      id,\n      listObjAttribute,\n      path: (id ? id+':' : '')+path,\n    }\n  }\n\n  handlerHashChange () {\n    const listRoutRaw = this.getListRout();\n    this.listRout = listRoutRaw.map(rout => this.processRout(rout));\n    this.fireMatchAll();\n    console.log('this.listRout:', this.listRout);\n  }\n\n  match( pathToMatch, fn ) {\n    for ( let indexListRout=0; indexListRout<this.listRout.length; indexListRout++ ) {\n      const rout = this.listRout[ indexListRout ];\n\n      if ( rout.path === pathToMatch ) {\n        return fn( rout.listObjAttribute );\n      }\n    }\n\n    return '';\n  }\n\n  matchPath( pathToMatch, fn ) {\n    this.listObjPathToMatch[ pathToMatch ] = fn;\n  }\n\n  fireMatchAll() {\n    for (let pathToMatch in this.listObjPathToMatch) {\n      const fn = this.listObjPathToMatch[ pathToMatch ];\n      fn();\n    }\n  }\n}\n\nexport default Router;"],"sourceRoot":""}